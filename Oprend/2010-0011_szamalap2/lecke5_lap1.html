<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="hu" lang="hu">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="css/scormelte_alap.css" rel="stylesheet" type="text/css" title="" />
<link href="css/style_spec.css" rel="stylesheet" type="text/css" />
<link href="css/scormelte_nagy.css" rel="alternate stylesheet" type="text/css" title="nagy" />
<link href="css/scormelte_inverz.css" rel="alternate stylesheet" type="text/css" title="inverz" />
<!--[if lte IE 6]>
<link href="css/scormelte_ie6.css" rel="stylesheet" type="text/css" title="" />
<![endif]-->
<!-- syntax highlight -->
<link rel="stylesheet" type="text/css" href="css/shCore.css" />
<link rel="stylesheet" type="text/css" href="css/shThemeDefault.css" />
<script type="text/javascript" src="js/shCore.js"></script>
<script type="text/javascript" src="js/shBrushCpp.js"></script>
<script type="text/javascript" src="js/shBrushCSharp.js"></script>
<script type="text/javascript" src="js/shBrushDelphi.js"></script>
<script type="text/javascript" src="js/shBrushXml.js"></script>
<script type="text/javascript" src="js/shBrushCss.js"></script>
<script type="text/javascript" src="js/shBrushJScript.js"></script>
<script type="text/javascript" src="js/shBrushSql.js"></script>
<script type="text/javascript">
SyntaxHighlighter.all()
</script>
<title>
Számítógépes alapismeretek II.</title>
<meta name="description" content="A tananyag  fejlesztése a TÁMOP-4.1.2.A/2-10/1 pályázat keretén belül történt." />
<meta name="keywords" content="Hardver alapismeretek, operációs rendszer, számítógépes alapismeretek, operációs rendszer fogalma, operációs rendszerek története, operációs rendszer feladata, operációs rendszer generációk, operációs rendszer típusok, folyamatok, folyamat táblázat, szál &ndash; folyamatok, rendszerhívások, operációs rendszer struktúrák, kernelmód, kernel, felhasználói mód, B/K művelet, folyamatok modellje, szinkron rendszerhívás, asszinkron rendszerhívás, állapotai, megvalósításuk, folyamatok kommunikációja, IPC (Inter Process Communication), megszakítástábla, IDT, megszakításvezérlő, PIC, megszakítás, interrupt, megszakításkérelem, IRQ, megszakításkezelési folyamat, kivétel, hibakeresés (debuggolás), töréspont, fájlrendszer, MBR, partíciós szektor, Ntldr, klaszter (cluster), szektor, FAT, NTFS, ext, TSS, csapda, ütemezés, szál, szemafor, mutex, monitor, POSIX, szignál, osztott memória, csővezeték, kritikus szakasz, Wybe Dijkstra, CPU, erőforrás, holtpont, kiéheztetés, integrált áramkör, multiprogramozás, beágyazott rendszerek, partíció, MMU, lapcsere, FIFO, socket, lapozás, swap, interaktív rendszer, kötegelt rendszer, kliens, job, jogosultság, metaadat, könyvtár, UNIX, GNU/LINUX, erőforrás-foglalási gráf, fizikai memória, virtuális memória, merevlemez, floppy, fregmentáció, defregmentáló program, MFT, API, i-node, cache memory, SSH, HyperThread, párhuzamosság" />
<script type="text/javascript" src="js/jquery-1.3.2.min.js"></script>
<script type="text/javascript" src="js/kep.js"></script>
<script type="text/javascript" src="js/jquery.media.js"></script>
<script type="text/javascript" src="js/jquery.highlight-3.js"></script>
<script type="text/javascript" src="js/kereses.js"></script>
<script type="text/javascript" src="js/stylesheetToggle.js"></script>
<script type="text/javascript" src="js/cookie.js"></script>
<script type="text/javascript" src="js/stilusvalto.js"></script>
<script type="text/javascript" src="js/fogalmak.js"></script>
<script type="text/javascript" src="js/fogalom.js"></script>
<script type="text/javascript" src="js/jwplayer.js"></script>
<script type="text/javascript">
$(document).ready(function() 
{
$("a.hang").media( {width: 250, height: 50,  autoplay: false} );
});
</script>
<script type="text/javascript" src="js/navigacio.js"></script>
</head>
<body>
<div><a name="teteje"  id="teteje"></a></div>
<div class="jawsfmenu">
  <ul>
    <li><a class="tartalom" href="#tartalom" accesskey="t" tabindex="2">Ugrás a <span class="gyorsb">t</span>artalomra</a></li>
    <li><a class="tartalomj" href="#fejezetek" accesskey="j" tabindex="5">Ugrás a tartalom<span class="gyorsb">j</span>egyzékre</a></li>
    <li><a class="tanutm" href="#tanutm" accesskey="u" tabindex="7">Ugrás a tan<span class="gyorsb">u</span>lási útmutatóra</a></li>
  </ul>
</div>
<div class="ki_kereses"></div>
<div class="oldal">
  <div class="utmutato">
    <div class="utm_hivatkozasok"><span class="elozolap"><img src="navi/ikon_vissza_dis.gif" alt="Vissza az előzőleg látogatott oldalra (nem elérhető funkció)" title="Vissza az előzőleg látogatott oldalra (nem elérhető funkció)" /></span><a class="kezdolap" href="index.html" accesskey="p" tabindex="21"><img src="navi/ikon_kezdolap.gif" alt="Vissza a modul kezdőlapjára" title="Vissza a modul kezdőlapjára" width="36" height="36"/></a><a class="elozotanlap" href="teszt/lecke4/teszt.html" accesskey="e" tabindex="22"><img src="navi/ikon_elozolap.gif" alt="Ugrás a tananyag előző oldalára" title="Ugrás a tananyag előző oldalára" width="36" height="36" /></a><a class="kovetktanlap" href="lecke5_lap2.html" accesskey="v" tabindex="23"><img src="navi/ikon_kovetklap.gif" alt="Ugrás a tananyag következő oldalára" title="Ugrás a tananyag következő oldalára" width="36" height="36"/></a><span class="ki_fogalomkapcs"><img src="navi/ikon_fogalmakbe_dis.gif" alt="Fogalom megjelenítés (nem elérhető funckió)" title="Fogalom megjelenítés (nem elérhető funckió)" /></span><span class="ki_fogalomlista"><img src="navi/ikon_fogalmaklista_dis.gif" alt="Fogalmak listája (nem elérhető funkció)" title="Fogalmak listája (nem elérhető funkció)" /></span><span class="ki_nyomtatas"><img src="navi/ikon_nyomtatas_dis.gif" alt="Oldal nyomtatása (nem elérhető funkció)" title="Oldal nyomtatása (nem elérhető funkció)" /></span><a class="oldalterkep" href="oldalterkep.html" accesskey="d" tabindex="31"><img src="navi/ikon_oldalterkep.gif" alt="Oldaltérkép megtekintése" title="Oldaltérkép megtekintése"  width="36" height="36" /></a><a class="sugo" href="sugo.html" accesskey="s" tabindex="33"><img src="navi/ikon_sugo.gif" alt="Súgó megtekintése" title="Súgó megtekintése"  width="36" height="36" /></a></div>
    <h1 class="utmutato"><a name="tanutm"  id="tanutm"></a>Tanulási útmutató</h1>
    <div class="osszefoglalas">
      <h2>Összefoglalás </h2>
      <!--{fej5_hang_1}--><div class="hang"><ul><li><strong>Cím:</strong> <a href="hangok/5.mp3">Multiprogramozás</a></li><li><strong>Hossz:</strong>1 perc 10 <abbr title="másodperc">mp.</abbr></li><li><strong>Fájlméret:</strong> 1.07 <abbr title="megabájt">MB</abbr></li><li><a class="media hang" name="playerf25" id="playerf25" href="hangok/5.mp3">Multiprogramozás című hanganyag letöltése</a></li><li><a href="hangok/5.html"><span class="jaws">Multiprogramozás című hanganyag</span>Szöveges változat megtekintése</a></li></ul></div><!--END{fej5_hang_1}--><p>A mai számítógépekre már nem csak az egyszerű, egyidejűleg csak egy feladat végrehajtási módja a jellemző. Elsősorban a hardverelemek teljesítményének növekedése miatt (nőtt a mikroprocesszor utasítás-végrehajtási sebessége, nőtt a memória mérete stb.) olyan alapprogram, azaz <span class="fogalom" title="operációs rendszer">operációs rendszer</span> készül a megfelelő hardverre, amely lehetővé teszi, hogy a felhasználó &ndash; ha úgy kívánja &ndash; egyszerre több feladatot is végrehajthasson a gépen. Ezt természetesen úgy teszi, hogy jellemzően rövid időközönként (10-20 milliszekundumonként) megszakítja az aktuális feladat végrehajtását, majd egy következő feladat végrehajtásába kezd. Olyan gyorsan képes a központi egység végrehajtani az utasításokat (több millió utasítást másodpercenként), hogy ha ezen sebesség mellett váltogatjuk az éppen végrehajtódó feladatokat, az számunkra azt az illúziót kelti, mintha egymással párhuzamosan történnének a feladat-végrehajtások. </p><p>A folyamatok közti gyors kapcsolást, a végrehajtás váltását <span class="fogalom" title="multiprogramozás">multiprogramozásnak</span> nevezzük. Egy folyamatból, azaz processzből több más parancs is indítható. Ahogy láttuk kezdő lépésként, ezt megtehetjük egy <span class="fogalom" title="UNIX">UNIX</span> vagy egy <span class="fogalom" title="UNIX">UNIX</span> -szerű (mint amilyen például a <span class="fogalom" title="GNU/LINUX">GNU/LINUX</span>) <span class="fogalom" title="operációs rendszer">operációs rendszerrel</span> működő kiszolgálóhoz kapcsolódva a shell, általában a &#132;bash&#148; révén. Azt a folyamatot, amelyből létrehozzuk az újabb folyamatokat, <em>szülőfolyamatnak</em> (egyszerűbben szülőnek) nevezik, míg az új folyamatokat <em>gyermekfolyamatnak</em> (egyszerűbben gyermeknek). A gyermekfolyamat örökli a szülőfolyamat tulajdonságait. </p><p>Az <span class="fogalom" title="operációs rendszer">operációs rendszernek</span> ahhoz, hogy ezeket a folyamatokat helyesen tudja kezelni, felügyelnie kell a folyamatokat. Az <span class="fogalom" title="operációs rendszer">operációs rendszerünk</span> így minden egyes folyamatot nyilvántart, és az <span class="fogalom" title="operációs rendszer">operációs rendszer</span> lelkének is nevezett ütemező (scheduler) segítségével szépen sorban minden egyes folyamatnak ad egy kis processzor- (<span class="fogalom" title="CPU">CPU</span>-) időszeletet, amíg az adott folyamat dolgozik, azaz a processzorra kerülhet. </p><p>A folyamatok önálló egységek, a központi memória egy szeletében helyezkednek el. Ahhoz, hogy a központi egység ezeket végre tudja hajtani, az kell, hogy a folyamatokhoz saját utasításszámláló, verem és egyéb állapotjelzők tartozzanak. Tudható, hogy a folyamatok közül biztosan egy folyamat fut mindig, az összes többi pedig arra vár, esetlegesen blokkolt állapotban, hogy lehetőséget kapjon a futásra, azaz processzoridőhöz jusson. </p><p>Elmondhatjuk azt is &ndash; a részletes vagy kevésbé részletes folyamatok modelljétől eltekintve &ndash;, hogy a folyamatok megfelelő <span class="fogalom" title="ütemezés">ütemezéséhez</span> az <span class="fogalom" title="operációs rendszer">operációs rendszernek</span> nyilván kell tartani minden olyan információt, ami a folyamat újraütemezéséhez szükséges. Ehhez a nyilvántartáshoz az <span class="fogalom" title="operációs rendszer">operációs rendszer</span> egy táblázatot használ, amit <strong>folyamattáblázatnak</strong> nevezünk. Gyakran olvashatjuk más irodalmakban erre a <strong>folyamatvezérlő blokk</strong> (Process Control Block &ndash; PCB) megnevezést. </p><p>Ha elindítunk egy programot a számítógépen, akkor a program utasítássorozata a kezdetétől fogva az utolsó utasításáig egy egyszerű, egymás utáni (szekvenciális) parancssorozatnak tekinthető. A legtöbb programot ma is ez jellemzi, de néha előfordul, hogy a feladatunk szempontjából célszerűbb lenne, ha több, &#132;párhuzamosan&#148; futó vezérlési <span class="fogalom" title="szál">szála</span> lenne a folyamatnak. Ezeket a vezérlési <span class="fogalom" title="szál">szálakat</span> egyszerűen <span class="fogalom" title="szál"><strong>szálnak</strong></span> (thread) nevezik. </p><p>Egy <span class="fogalom" title="szál">szálnak</span> is vannak regiszterei az aktuális változók tárolására, van utasításszámlálója, ami mutatja az aktuálisan következő utasítást, és tartozik hozzá verem is, hiszen a függvények hívási módja megköveteli ennek a meglétét. </p><p>Ha a <span class="fogalom" title="szál">szálra</span> jellemző információkat tárolni kell, márpedig ezek minden <span class="fogalom" title="szál">szálra</span> egyediek, akkor az adatokat &ndash; a folyamatokhoz hasonlóan &ndash; egy táblázatban célszerű elraktározni. Ebben a táblázatban annyi bejegyzés van, ahány <span class="fogalom" title="szál">szálat</span> létrehoz a folyamat. Az ilyen párhuzamosan futó vezérlési <span class="fogalom" title="szál">szálak</span> egy közös memóriaterületet használnak, amit az eredeti folyamat címtartományából, memóriaterületéből kapnak. </p><p>A legjellemzőbb sajátosságok, amelyek egy folyamatban biztosan vannak, de egy <span class="fogalom" title="szál">szálban</span> (száltáblában) pedig biztosan nincsenek, a következők: </p><ul><li>címtartomány, </li><li>globális változók, </li><li>nyitott fájlleírók, </li><li>gyermekfolyamatok, </li><li>jelzések (<span class="fogalom" title="szignál">szignálok</span>), </li><li>jelzéskezelők, </li><li>függőben lévő ébresztők. </li></ul><p>Egy <span class="fogalom" title="szál">szálban</span> is biztosan nyilván kell tartani az alábbiakat (természetesen ezek egy folyamathoz is kötődnek): </p><ul><li>utasításszámláló, </li><li>regiszterek, </li><li>verem, </li><li>szálállapot. </li></ul> 
    </div>
    <div class="kovetelmeny">
      <h2>Követelmény </h2>
      <p>A tanuló ismerje az egyfeladatos és a többfeladatos <span class="fogalom" title="operációs rendszer">operációs rendszerek</span> fogalmát, jellemzőit. A tanulónak legyen ismerete az <span class="fogalom" title="ütemezés">ütemezés</span>, a program, a folyamat és a <span class="fogalom" title="szál">szálak</span> fogalmáról, illetve azok jellemzőiről. Ismerje, és legyen képes különbséget tenni a folyamatok párhuzamos és szekvenciális végrehajtása között, tudja alkalmazni az alapvető parancsindítási lehetőségeket. Ismerje a programozási környezet folyamat-létrehozó függvényeit, a parancsindítás alapvető folyamatát. A tanuló ismerje a folyamatok és a <span class="fogalom" title="szál">szálak</span> nyilvántartásának módját, legfontosabb adatait. </p> 
    </div>
    <div class="feladatok">
      <h2>Önállóan megoldható feladatok</h2>
      <ul><li>Indítson el a háttérben egy hosszan végrehajtódó parancsot, majd vizsgálja meg a /proc könyvtárban létrejövő nyilvántartási adatait! [Segítség a megoldáshoz: a ps paranccsal megtudhatjuk az indított folyamat azonosítóját (PID), majd vizsgálja a /proc/PID könyvtár tartalmát.] </li><li>Egy új folyamat indítását az exec függvénycsalád egyik tagjának hívásával érhetjük el. A referencia-kézikönyv (manual) segítségét is felhasználva (a man parancs) sorolja fel az exec függvénycsalád különböző alakjait! </li><li>Sorolja fel, hogy a folyamatok nyilvántartása során milyen információkat tárol az operációs rendszer egy-egy folyamatról! </li><li>Az operációs rendszer top nevű parancsa az operációs rendszer erőforrásairól, működő folyamatairól ad tájékoztatást. (A parancsból a q billentyű leütésével lehet kilépni!) Értelmezze a kapott információkat! Honnan gyűjti össze a top parancs a képernyőn megjelenő adatokat? </li><li>Soroljon fel legalább három olyan adatot, amelyeket mind a szálak, mind a folyamatok kapcsán nyilván kell tartani, és mondjon legalább három olyan adatot, amelyeket csak a folyamat esetében kell nyilvántartani! </li><li>Készítsen olyan alkalmazást, amelynek segítségével demonstrálni tudja egy vagy több interaktív ütemezési algoritmus működését! A program indulásakor legyen <em>N</em> folyamat a memóriában, és minden folyamatot reprezentáljunk egy számmal! Legyen ez <em>I,</em> és tudjuk, hogy: 1 &lt;= <em>I,</em> és <em>I</em> &lt;= <em>N</em>. A fejlesztési környezet időzítő függvényét kihasználva készítse el azt a szimulációt, hogy egy ütemezési idő letelte után melyik folyamat is kapja meg a vezérlést! (Használjon olyan környezetet, amit legjobban ismer!)</li></ul> 
    </div>
  </div>
  <div class="tartalommenu">
    <div class="tartalommenu_fejlec"><span id="lapteteje"><a  href="#teteje"><span class="gyorsb">F</span>el a lap tetejére</a></span><a name="fejezetek"   id="fejezetek">Tartalomjegyzék</a></div>
    <ul><li><a href="#hiv1">Folyamatok, folyamatleírók, táblázatok és szálak fogalma. A folyamatok és a szálak közötti különbségek, a folyamatok ütemezése</a><ul><li><a href="#hiv2">A folyamatok modellje</a></li><li><a href="#hiv3">Parancs-végrehajtási környezet</a></li><li><a href="#hiv4">Programozási környezet</a><ul><li><a href="#hiv5">A system rendszerhívás használata</a></li><li><a href="#hiv6">Az exec rendszerhívás-család használata</a></li></ul></li></ul></li></ul> 
  </div>
  <div class="tartalom"> <a name="tartalom" id="tartalom"></a> 
    <h1><a name="hiv1" id="hiv1" ></a>Folyamatok, folyamatleírók, táblázatok és szálak fogalma. A folyamatok és a szálak közötti különbségek, a folyamatok ütemezése</h1><h2><a name="hiv2" id="hiv2" ></a>A folyamatok modellje</h2><p>A korábbi fejezetekben, illetve a korábbi tanulmányokban is láthattuk, hogy egy számítógép felépítését alapvetően két részre bonthatjuk. Az igazán kézbe vehető részt egyszerűen hardvernek, míg azt a programot, programcsomagot, amelyik ezt a hardvert működő géppé, számítógéppé teszi, szoftvernek (avagy szoftverprogramnak) nevezzük. A szoftverprogram gyakran egy egyszerű, egyetlen feladatot végrehajtó egység. Ezeket a rendszereket a szakirodalom gyakran beágyazott (embedded) rendszereknek hívja. </p><p>Ezek általában egy célfeladatra készülnek, így sokszor fel sem tűnik, hogy az eszköz maga valójában egy számítógép. Ilyen rendszerek (gépek) ma is körülvesznek bennünket, például egy mai automata mosógép mosási programjait egy efféle beépített (beágyazott) miniszámítógép vezérli. Említhetjük példaként a múltból azt a Z-80 mikroprocesszor köré épített kis számítógépet, amelyik egy templom automatikus harangozó feladatait végzi el. A <span class="fogalom" title="beágyazott rendszerek">beágyazott rendszerek</span> általános jellemzője, hogy bekapcsolásukkor úgymond &#132;elindul a program&#148;, ami csak egyféle tevékenységről szól: végrehajtódik a beállított mosási típusnak megfelelő utasítássor, vagy az adott időben egy vagy több haranggal valamennyi ideig harangozunk (bekapcsoljuk a harangozó villamos motort), majd a feladat végrehajtása után a program befejezi a tevékenységet.</p><p>Egyszerre egy tevékenység végrehajtása természetesen nem csak ilyen speciális, <span class="fogalom" title="beágyazott rendszerek">beágyazott rendszereknél</span> fordul elő. Általánosan ez volt a jellemző a személyi számítógép megjelenésekor, az 1980-as évek elején; ilyen volt például a Commodore-64 számítógép a Basic környezetével, programozási nyelvével, vagy az IBM PC a DOS (Disk Operating System) <span class="fogalom" title="operációs rendszer">operációs rendszerével</span>. </p><p>A mai számítógépekre már nem csak az egyszerű, egyidejűleg csak egy feladat végrehajtási módja a jellemző. Elsősorban a hardverelemek teljesítményének növekedése miatt (nőtt a mikroprocesszor-utasítás végrehajtási sebessége, nőtt a memória mérete stb.) olyan alapprogram, azaz <span class="fogalom" title="operációs rendszer">operációs rendszer</span> készül a megfelelő hardverre, amely révén a felhasználó &ndash; ha úgy kívánja &ndash; egyszerre több feladatot is végrehajthat. Ezt természetesen úgy végzi el, hogy jellemzően rövid időközönként (10-20 milliszekundumonként) megszakítja az aktuális feladat végrehajtását, majd egy következő feladat végrehajtásába kezd. </p><p>A mai számítógépek alapprogramjai már mind ilyenek, legyen az a Microsoft Windows, vagy valamilyen <span class="fogalom" title="UNIX">UNIX</span> vagy <span class="fogalom" title="UNIX">UNIX</span> -szerű <span class="fogalom" title="operációs rendszer">operációs rendszer</span>, és ezeket úgynevezett &#132;multitasking&#148;, avagy többfeladatos <span class="fogalom" title="operációs rendszer">operációs rendszernek</span> is nevezzük. Ehhez még az adódik, hogy a hálózati kacsolódás lehetőségét kihasználva egyidejűleg akár több felhasználó is előírhatja a végrehajtandó feladatokat. Tehát egy felhasználó az <span class="fogalom" title="operációs rendszer">operációs rendszerben</span> egyidejűleg több feladatot és parancsot hajthat végre, vagy egyidejűleg akár több felhasználó is csatlakozhat az adott számítógéphez.</p><p>Egy felhasználó az úgynevezett számítógép-terminálon kapcsolódhat a számítógéphez. Az <span class="fogalom" title="operációs rendszer">operációs rendszerben</span> ezt a kapcsolódást egy fogadó program várja. [Gyakran ennek getty a neve, a <em>t</em>ele<em>ty</em>pe (terminál) fogadása (<em>get</em>) kifejezések jelentése miatt.] A fogadó program elfedi a többi szolgáltatást, illetve rajta keresztül tudjuk a további szolgáltatásokat igénybe venni. A fogadó programot gyakran nevezik buroknak, héjnak is (shell).</p><p>Bár kiindulhatnánk egy <span class="fogalom" title="operációs rendszer">operációs rendszer</span> indulási folyamatából is, de hasonló helyzet áll elő, amikor egy felhasználó elkezdi a munkát, amit a megfelelő fogadó (shell) programmal való tevékenysége mutat. Mivel többfeladatos (multitasking) környezetről van szó, meg kell néznünk, hogy milyen lehetőségek vannak ennek a kihasználására.</p><p>Két környezetet kell megnézni: az egyik a parancs-végrehajtási környezet, a másik a programozási környezet.</p><p class="vissza"><a href="#fejezetek">Vissza a tartalom<span class="gyorsb">j</span>egyzékhez</a></p><h2><a name="hiv3" id="hiv3" ></a>Parancs-végrehajtási környezet</h2><p>A parancs-végrehajtási környezet alapvető tulajdonsága, hogy kezeli a felhasználó terminálját, beolvassa a billentyűzetről begépelt parancsot, és végrehajtja azt. A parancs eredményét a képernyőre kiírja, majd várja az újabb parancsokat <em>(5.1. ábra)</em>.</p><!--fej5_kep_1--><div class="kep kozep sz300"><img src="kepek/fej5_kep1_w300.jpg" alt="A képen a parancssor látható működés közben" style="width:100%; height:auto;" title="A képen a parancssor látható működés közben" /><span class="kepalairas">5.1 ábra: A parancsok kiadása, végrehajtása és megjelenítése a képernyőn</span></div><div class="uresmargo"></div><!--ENDfej5_kep_1--><p>Fontos megjegyezni, hogy például a fenti parancsok kiadása után, a parancs befejeződéséig nincs lehetőség másik parancs kiadására. Kérdés merülhet fel ekkor az olvasóban: ekkor hogyan tudunk mégis egyszerre több parancsot végrehajtani? Ezt nagyon egyszerűen meg tudjuk oldani: amikor begépeljük a parancs-végrehajtási környezetnek a parancsot, a parancs után egy &#132;&#38;&#148; jelet kell beírnunk, és így kell futtatnunk a parancsot. Ekkor a parancs a háttérben kezd el futni, és mi újabb parancsokat tudunk a háttérben futó parancs mellett kiadni, vagyis megvalósítottuk a több feladat végrehajtását egyszerre.</p><p>Az <em>5.2. ábra</em> alapján látható, hogy ez a lehetőség kényelmes eszköz olyan számolásigényes feladatok végrehajtására a háttérben, amelyek nem igényelnek közvetlen terminálműveleteket (ilyen például a képernyőre írás vagy a billentyűzetről olvasás is). A háttérben indított parancsok, ha befejezik a tevékenységüket, akkor erről egy &#132;Done&#148; jelzésű sorral adnak figyelmeztetést.</p><!--fej5_kep_2--><div class="kep kozep sz350"><img src="kepek/fej5_kep2_w350.jpg" alt="A képen az látható, hogy hogyan lehet a háttérben és előtérben egyszerre parancsot indítani" style="width:100%; height:auto;" title="A képen az látható, hogy hogyan lehet a háttérben és előtérben egyszerre parancsot indítani" longdesc="kepek/fej5_kep2_w350.html" /><span class="kepalairas">5.2 ábra: Parancsindítás a háttérben és előtérben egyszerre</span></div><div class="uresmargo"></div><!--ENDfej5_kep_2--><p>Egy folyamatból, azaz processzből több más parancs is indítható. Ezt megtehetjük egy <span class="fogalom" title="UNIX">UNIX</span> vagy egy <span class="fogalom" title="UNIX">UNIX</span> -szerű (mint amilyen például a <span class="fogalom" title="GNU/LINUX">GNU/LINUX</span>) <span class="fogalom" title="operációs rendszer">operációs rendszerrel</span> működő kiszolgálóhoz kapcsolódva a shell, általában a &#132;bash&#148; révén. Azt a folyamatot, amelyből létrehozzuk az újabb folyamatokat, szülőfolyamatnak (egyszerűbben szülőnek) nevezik, míg az új folyamatokat gyermekfolyamatnak (egyszerűbben gyermeknek). A gyermekfolyamat örökli a szülőfolyamat tulajdonságait. </p><p>Az <span class="fogalom" title="operációs rendszer">operációs rendszernek</span> ahhoz, hogy ezeket a folyamatokat helyesen tudja kezelni, felügyelnie kell a folyamatokat. Az <span class="fogalom" title="operációs rendszer">operációs rendszerünk</span> így minden egyes folyamatot nyilvántart, és az <span class="fogalom" title="operációs rendszer">operációs rendszer</span> lelkének is nevezett <strong>ütemező</strong> (scheduler) segítségével szépen sorban minden egyes folyamatnak ad egy kis processzor- (<span class="fogalom" title="CPU">CPU</span>-) időszeletet, amíg az adott folyamat dolgozik, azaz a processzorra kerülhet. </p><p>Az <em>5.3. ábrá</em>n az látható, hogy egy <span class="fogalom" title="UNIX">UNIX</span> vagy <span class="fogalom" title="UNIX">UNIX</span> -szerű <span class="fogalom" title="operációs rendszer">operációs rendszerben</span> (mint amilyen a <span class="fogalom" title="GNU/LINUX">GNU/LINUX</span> <span class="fogalom" title="operációs rendszer">operációs rendszer</span> is) a &#132;/proc&#148; <span class="fogalom" title="könyvtár">könyvtár</span> jelenti a folyamatok központi nyilvántartási helyét. </p><!--fej5_kep_3--><div class="kep kozep sz650"><img src="kepek/fej5_kep3_w650.jpg" alt="Az képen az látható, hogy egy UNIX vagy Unix-szerű operációs rendszerben " style="width:100%; height:auto;" title="Az képen az látható, hogy egy UNIX vagy Unix-szerű operációs rendszerben " longdesc="kepek/fej5_kep3_w650.html" /><span class="kepalairas">5.3. ábra: A "/proc" elérési útvonal alatt levő könyvtár tartalma</span></div><div class="uresmargo"></div><!--ENDfej5_kep_3--><p>Az ábrán látható, hogy azok a <span class="fogalom" title="könyvtár">könyvtárak</span>, amelyeknek neve számokból áll, egy-egy folyamat jellemzőit tartalmazzák, míg az egyéb állományok más, működéshez szükséges rendszerjellemzőket foglalnak magukban. Például az &#132;<span class="fogalom" title="megszakítás">megszakítás</span>s&#148; fájl a processzormagok megszakításállapotait írja le. (Az olyan <span class="fogalom" title="könyvtár">könyvtárak</span> között, amelyeknek neve számokból áll, mindig van &#132;1&#148; nevű, mert az az első, a rendszer indulásakor létrejövő folyamat. Az ebből és az utódokból születő újabb folyamatok kapják a nagyobb, nem feltétlenül sorrendben növekvő számokat.) </p><p class="vissza"><a href="#fejezetek">Vissza a tartalom<span class="gyorsb">j</span>egyzékhez</a></p><h2><a name="hiv4" id="hiv4" ></a>Programozási környezet</h2><p>Attól függően, hogy a folyamatok önként mondanak-e le a processzoridőhöz való jutásról, vagy sem, az <span class="fogalom" title="operációs rendszer">operációs rendszer</span> kooperatívnak vagy preemptívnek minősítik. Az <span class="fogalom" title="operációs rendszer">operációs rendszert</span> <strong>kooperatív</strong>, ha benne a folyamatok önként mondanak le a processzoridőhöz jutásról, viszont <strong>preemptív </strong>akkor, ha a folyamatokat egy külső erő szakíthatja félbe. Kooperatív <span class="fogalom" title="operációs rendszer">operációs rendszer</span> például a Microsoft Windows 3.1, míg a <span class="fogalom" title="UNIX">UNIX</span> és a Microsoft Windows 7 esetében preemptív <span class="fogalom" title="operációs rendszer">operációs rendszerről</span> van szó.</p><p>A folyamatok gyakran nemcsak önmagukban számolnak, végeznek feladatokat, hanem az <span class="fogalom" title="operációs rendszer">operációs rendszer</span> lehetőségeit is igénybe vehetjük: <span class="fogalom" title="rendszerhívás">rendszerhívás</span> formájában kérhetünk segítséget ahhoz, hogy egy program vagy az <span class="fogalom" title="operációs rendszer">operációs rendszer</span> fennhatósága alá eső fájlokkal (eszközzel) vagy egy másik folyamattal kommunikáljunk. A folyamatok működése során gyakori feladat, hogy más alkalmazás szolgáltatását vegyük igénybe.</p><p>Mielőtt rátérnénk a lecke címében leírtak részletezésére, nézzünk meg egy olyan <span class="fogalom" title="rendszerhívás">rendszerhívást</span>, melynek van megfelelője az MS-DOS <span class="fogalom" title="operációs rendszer">operációs rendszerbeli</span> <span class="fogalom" title="könyvtár">könyvtárakban</span> is. A programból egy <span class="fogalom" title="operációs rendszer">operációs rendszerbeli</span> parancsot pontosan úgy hajthatunk végre, mintha a shellben lennénk. Ez a &#132;system&#148; <span class="fogalom" title="rendszerhívás">rendszerhívás</span>. </p><p>A <strong>system</strong> <span class="fogalom" title="rendszerhívás">rendszerhívásnak</span> egyetlen paramétere van, ami egy karaktersorozat: pontosan egy shell parancs. A <span class="fogalom" title="rendszerhívás">rendszerhívás</span> visszatérési értéke pedig a shell exit státusza a parancs végrehajtása után.</p><p>Nézzünk néhány példát a <span class="fogalom" title="rendszerhívás">rendszerhívások</span> használatára egy C programozási nyelvű programkódból!</p><h3><a name="hiv5" id="hiv5" ></a>A system rendszerhívás használata</h3><p><em>Példa a system rendszerhívás használatára: az &#132;ls &ndash;al&#148; parancs végrehajtása egy C programozási nyelvű programkódból:</em></p><div class="forraskod"><div class="bekezdes1cm">

#include &lt;iostream.h&gt; 
void main() { 
     int status; 
     cout &lt;&lt; &#148;Elinditom az ls -al parancsot!\n&#148;; 
     status = system("ls -al&#148;); 
     // Ennek a végrehajtása alatt a programom várja a system 
     // rendszerhívás végét. 
     cout &lt;&lt; &#148;Az eredmeny: &#148; &lt;&lt; status; 
}  
</div>
</div><h3><a name="hiv6" id="hiv6" ></a>Az exec rendszerhívás-család használata</h3><p>A system <span class="fogalom" title="rendszerhívás">rendszerhívásnak</span> vannak egy kicsinykét másként működő társai, ezek a <span class="fogalom" title="rendszerhívás">rendszerhívások</span> az <strong>exec</strong> <span class="fogalom" title="rendszerhívás">rendszerhívás</span> -család tagjai. Amíg a system <span class="fogalom" title="rendszerhívás">rendszerhívás</span> úgy működik, mint egy normál függvényhívás, addig az exec <span class="fogalom" title="rendszerhívás">rendszerhívás</span> -család olyan, mint egy &#132;vezetőváltást&#148; végrehajtó diktátum. A hívásig a hívó fél van nyeregben (a memóriában), majd utána a hívott fél kerül a helyére. Az exec <span class="fogalom" title="rendszerhívás">rendszerhívás</span> -család tagjaiból a hívó programba való visszatérés sohasem történik meg! </p><p>Az exec <span class="fogalom" title="rendszerhívás">rendszerhívás</span> -család tagjai két alapformában léteznek, ezek: az <strong>execl</strong> <span class="fogalom" title="rendszerhívás">rendszerhívás</span>, illetve az <strong>execv </strong><span class="fogalom" title="rendszerhívás">rendszerhívás</span>. </p><p>Az <strong>execl</strong> <span class="fogalom" title="rendszerhívás">rendszerhívásnak</span> tetszőleges darabszámú paramétere lehet, a végüket egy NULL pointer jelzi. Egyébként mindegyik paraméter &#132;char *&#148; típusú. Az első paraméter az elérési útvonallal kiegészített végrehajtandó parancs neve, a másodiknak nincs sok jelentősége, konvencionálisan ez maga a parancs szintén (elérési útvonal nélkül), majd a következő paraméterek az első paraméterként megadott parancsunk paraméterei lesznek.</p><p>Az <strong>execv</strong> <span class="fogalom" title="rendszerhívás">rendszerhívásnak</span> két paramétere van összesen, az első paraméter &#132;char *&#148; típusú, és az execl <span class="fogalom" title="rendszerhívás">rendszerhíváshoz</span> hasonlóan a végrehajtandó parancs nevét tartalmazza, míg a második paraméter egy karaktermutató tömb, aminek ugyanaz a szerepe és formája, mint a main függvény &#132;argv&#148; tömbjének.</p><p>A fenti két <span class="fogalom" title="rendszerhívás">rendszerhívásnak</span> van egy &#132;e&#148; betűvel kiegészített társuk is (azaz az <strong>execle</strong> és az <strong>execve</strong> <span class="fogalom" title="rendszerhívás">rendszerhívások</span>), amelyek egy paraméterrel, a környezeti változók (<strong>e</strong>nvironment) karaktermutató tömbjével egészülnek ki. Ezt jellemző módon a programok a main függvénytől kölcsönzik.</p><p><em> Példa az exec rendszerhívás használatára egy C programozási nyelvű programkódból</em></p><p>Mivel az exec <span class="fogalom" title="rendszerhívás">rendszerhívás</span> -család tagjai a hívó felet lecserélik, ezért egy program csak úgy nemigen használja ezeket a <span class="fogalom" title="rendszerhívás">rendszerhívásokat</span>. Viszont van egy jellemzően előforduló használata az exec <span class="fogalom" title="rendszerhívás">rendszerhívás</span> -család tagjainak: a fork <span class="fogalom" title="rendszerhívás">rendszerhívás</span> használatával, a gyermekfolyamatban hívjuk meg az exec <span class="fogalom" title="rendszerhívás">rendszerhívás</span> -család tagjait.</p><p>Nézzük meg a fork <span class="fogalom" title="rendszerhívás">rendszerhívással</span> ezt a jellemzően előforduló használatot! A következő kis program az előző programunk &#132;exec-esített és fork-osított&#148; változata, tehát szintén az &#132;ls &ndash;al&#148; parancsot hajtjuk végre egy C programozási nyelvű programkódból.</p><div class="forraskod"><div class="bekezdes1cm">

void main() { 
     int a,b; 
     a = fork(); 
     if (a) { 
          printf("Hello, ez a szulo, ami var most!\n"); 
          printf("Most varakozik a wait....\n"); 
          wait(&#38;b); 
          printf("Most van vege a szulo varakozasanak...\n"); 
     } else { 
          printf("Ez a gyermek processz! Most indul az execl...\n"); 
          execl("/usr/bin/ls","ls",&#148;/al&#148;,0); 
          printf("Es ezzel a kiirassal ez le is fut...\n"); 
          /* Ez az utóbbi kiírás természetesen már nem jelenik meg 
             a képernyőn, mivel a gyermek processz lecserélte magát 
             az ls parancsra! */ 
     }; 
}
</div>
</div><p class="vissza"><a href="#fejezetek">Vissza a tartalom<span class="gyorsb">j</span>egyzékhez</a></p> 
  </div>
</div>
<div class="utmutato_also">
  <div class="utm_hivatkozasok_also"><a class="oldalteteje" accesskey="f" href="#teteje"><span class="gyorsb">F</span>el a lap tetejére</a>
  <a class="elozotanlap" id="navialsoelozo" href="teszt/lecke4/teszt.html"><img src="navi/ikon_elozolap.gif" alt="Ugrás a tananyag előző oldalára" title="Ugrás a tananyag előző oldalára" width="36" height="36" /></a>
  <a id='navialsokov' class="kovetktanlap" href="lecke5_lap2.html"><img src="navi/ikon_kovetklap.gif" alt="Ugrás a tananyag következő oldalára" title="Ugrás a tananyag következő oldalára" width="36" height="36"/></a>
  </div>
</div>
<div class="ki_stilus"></div>
<div class="impresszum">
  <table class="uszt">
    <tr>
      <td><div class="imp_eltetatklogo"><img alt="ELTE és ELTE TáTK logó" src="css/arculat/elte_plus_tatk.png" style="width:100%;height:auto;" /></div>
        <div class="imp_elteiklogo"><img alt="ELTE és ELTE IK logó" src="css/arculat/elte_plus_ik.png" style="width:100%;height:auto;" /></div></td>
      <td><div class="imp_uszt"><img alt="Új Széchenyi terv" src="css/arculat/USZT_logo_cmyk.jpg" style="width:100%;height:auto;" /></div></td>
      <td><div class="imp_eu"><img alt="A projekt az Európai Unió támogatásával, az Európai Szociális Alap társfinanszirozásával valósul meg." title="A projekt az Európai Unió támogatásával, az Európai Szociális Alap társfinanszirozásával valósul meg." src="css/arculat/ESZA.png" style="width:100%;height:auto;"/></div></td>
    </tr>
  </table>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="hu" lang="hu">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="css/scormelte_alap.css" rel="stylesheet" type="text/css" title="" />
<link href="css/style_spec.css" rel="stylesheet" type="text/css" />
<link href="css/scormelte_nagy.css" rel="alternate stylesheet" type="text/css" title="nagy" />
<link href="css/scormelte_inverz.css" rel="alternate stylesheet" type="text/css" title="inverz" />
<!--[if lte IE 6]>
<link href="css/scormelte_ie6.css" rel="stylesheet" type="text/css" title="" />
<![endif]-->
<!-- syntax highlight -->
<link rel="stylesheet" type="text/css" href="css/shCore.css" />
<link rel="stylesheet" type="text/css" href="css/shThemeDefault.css" />
<script type="text/javascript" src="js/shCore.js"></script>
<script type="text/javascript" src="js/shBrushCpp.js"></script>
<script type="text/javascript" src="js/shBrushCSharp.js"></script>
<script type="text/javascript" src="js/shBrushDelphi.js"></script>
<script type="text/javascript" src="js/shBrushXml.js"></script>
<script type="text/javascript" src="js/shBrushCss.js"></script>
<script type="text/javascript" src="js/shBrushJScript.js"></script>
<script type="text/javascript" src="js/shBrushSql.js"></script>
<script type="text/javascript">
SyntaxHighlighter.all()
</script>
<title>
Számítógépes alapismeretek II.</title>
<meta name="description" content="A tananyag  fejlesztése a TÁMOP-4.1.2.A/2-10/1 pályázat keretén belül történt." />
<meta name="keywords" content="Hardver alapismeretek, operációs rendszer, számítógépes alapismeretek, operációs rendszer fogalma, operációs rendszerek története, operációs rendszer feladata, operációs rendszer generációk, operációs rendszer típusok, folyamatok, folyamat táblázat, szál &ndash; folyamatok, rendszerhívások, operációs rendszer struktúrák, kernelmód, kernel, felhasználói mód, B/K művelet, folyamatok modellje, szinkron rendszerhívás, asszinkron rendszerhívás, állapotai, megvalósításuk, folyamatok kommunikációja, IPC (Inter Process Communication), megszakítástábla, IDT, megszakításvezérlő, PIC, megszakítás, interrupt, megszakításkérelem, IRQ, megszakításkezelési folyamat, kivétel, hibakeresés (debuggolás), töréspont, fájlrendszer, MBR, partíciós szektor, Ntldr, klaszter (cluster), szektor, FAT, NTFS, ext, TSS, csapda, ütemezés, szál, szemafor, mutex, monitor, POSIX, szignál, osztott memória, csővezeték, kritikus szakasz, Wybe Dijkstra, CPU, erőforrás, holtpont, kiéheztetés, integrált áramkör, multiprogramozás, beágyazott rendszerek, partíció, MMU, lapcsere, FIFO, socket, lapozás, swap, interaktív rendszer, kötegelt rendszer, kliens, job, jogosultság, metaadat, könyvtár, UNIX, GNU/LINUX, erőforrás-foglalási gráf, fizikai memória, virtuális memória, merevlemez, floppy, fregmentáció, defregmentáló program, MFT, API, i-node, cache memory, SSH, HyperThread, párhuzamosság" />
<script type="text/javascript" src="js/jquery-1.3.2.min.js"></script>
<script type="text/javascript" src="js/kep.js"></script>
<script type="text/javascript" src="js/jquery.media.js"></script>
<script type="text/javascript" src="js/jquery.highlight-3.js"></script>
<script type="text/javascript" src="js/kereses.js"></script>
<script type="text/javascript" src="js/stylesheetToggle.js"></script>
<script type="text/javascript" src="js/cookie.js"></script>
<script type="text/javascript" src="js/stilusvalto.js"></script>
<script type="text/javascript" src="js/fogalmak.js"></script>
<script type="text/javascript" src="js/fogalom.js"></script>
<script type="text/javascript" src="js/jwplayer.js"></script>
<script type="text/javascript">
$(document).ready(function() 
{
$("a.hang").media( {width: 250, height: 50,  autoplay: false} );
});
</script>
<script type="text/javascript" src="js/navigacio.js"></script>
</head>
<body>
<div><a name="teteje"  id="teteje"></a></div>
<div class="jawsfmenu">
  <ul>
    <li><a class="tartalom" href="#tartalom" accesskey="t" tabindex="2">Ugrás a <span class="gyorsb">t</span>artalomra</a></li>
    <li><a class="tartalomj" href="#fejezetek" accesskey="j" tabindex="5">Ugrás a tartalom<span class="gyorsb">j</span>egyzékre</a></li>
    <li><a class="tanutm" href="#tanutm" accesskey="u" tabindex="7">Ugrás a tan<span class="gyorsb">u</span>lási útmutatóra</a></li>
  </ul>
</div>
<div class="ki_kereses"></div>
<div class="oldal">
  <div class="utmutato">
    <div class="utm_hivatkozasok"><span class="elozolap"><img src="navi/ikon_vissza_dis.gif" alt="Vissza az előzőleg látogatott oldalra (nem elérhető funkció)" title="Vissza az előzőleg látogatott oldalra (nem elérhető funkció)" /></span><a class="kezdolap" href="index.html" accesskey="p" tabindex="21"><img src="navi/ikon_kezdolap.gif" alt="Vissza a modul kezdőlapjára" title="Vissza a modul kezdőlapjára" width="36" height="36"/></a><a class="elozotanlap" href="teszt/lecke5/teszt.html" accesskey="e" tabindex="22"><img src="navi/ikon_elozolap.gif" alt="Ugrás a tananyag előző oldalára" title="Ugrás a tananyag előző oldalára" width="36" height="36" /></a><a class="kovetktanlap" href="lecke6_lap2.html" accesskey="v" tabindex="23"><img src="navi/ikon_kovetklap.gif" alt="Ugrás a tananyag következő oldalára" title="Ugrás a tananyag következő oldalára" width="36" height="36"/></a><span class="ki_fogalomkapcs"><img src="navi/ikon_fogalmakbe_dis.gif" alt="Fogalom megjelenítés (nem elérhető funckió)" title="Fogalom megjelenítés (nem elérhető funckió)" /></span><span class="ki_fogalomlista"><img src="navi/ikon_fogalmaklista_dis.gif" alt="Fogalmak listája (nem elérhető funkció)" title="Fogalmak listája (nem elérhető funkció)" /></span><span class="ki_nyomtatas"><img src="navi/ikon_nyomtatas_dis.gif" alt="Oldal nyomtatása (nem elérhető funkció)" title="Oldal nyomtatása (nem elérhető funkció)" /></span><a class="oldalterkep" href="oldalterkep.html" accesskey="d" tabindex="31"><img src="navi/ikon_oldalterkep.gif" alt="Oldaltérkép megtekintése" title="Oldaltérkép megtekintése"  width="36" height="36" /></a><a class="sugo" href="sugo.html" accesskey="s" tabindex="33"><img src="navi/ikon_sugo.gif" alt="Súgó megtekintése" title="Súgó megtekintése"  width="36" height="36" /></a></div>
    <h1 class="utmutato"><a name="tanutm"  id="tanutm"></a>Tanulási útmutató</h1>
    <div class="osszefoglalas">
      <h2>Összefoglalás </h2>
      <!--{fej6_hang_1}--><div class="hang"><ul><li><strong>Cím:</strong> <a href="hangok/6.mp3">A többfeladatos operációs rendszer</a></li><li><strong>Hossz:</strong>2 perc 12 <abbr title="másodperc">mp.</abbr></li><li><strong>Fájlméret:</strong> 2.02 <abbr title="megabájt">MB</abbr></li><li><a class="media hang" name="playerf25" id="playerf25" href="hangok/6.mp3">A többfeladatos operációs rendszer című hanganyag letöltése</a></li><li><a href="hangok/6.html"><span class="jaws">A többfeladatos operációs rendszer című hanganyag</span>Szöveges változat megtekintése</a></li></ul></div><!--END{fej6_hang_1}--><p>A többfeladatos, <span class="fogalom" title="multiprogramozás">multiprogramozásos</span> modellt használó <span class="fogalom" title="operációs rendszer">operációs rendszer</span> nyilvántartja az éppen &#132;futó&#148; folyamatokat, és gondoskodik arról, hogy ezek szép sorban végrehajtódjanak. A folyamatok működése során gyakran felmerülnek olyan igények, amikor egyik folyamatnak a helyes működéséhez szüksége van egy másik folyamat valamilyen közreműködésére, kommunikációjára. A folyamatok ilyenféle kommunikációját gyakran rövidíti a szakirodalom az &#132;IPC&#148; kifejezéssel, ami az InterProcess Communication kifejezés rövidítése.<br/>Ezzel kapcsolatban három területet kell megvizsgálni: </p><ul><li>meg kell adni, hogy egy folyamat hogyan tud információt küldeni egy másik folyamatnak;</li><li>biztosítani kell, hogy kettő vagy több folyamat ne keresztezze egymás útját, azaz ne ugyanazt a tevékenységet akarják egyszerre végrehajtani (kölcsönös kizárás); illetve </li><li>biztosítani kell, hogy a megfelelő (helyes) sorrendben történjen meg a feladat végrehajtása.</li></ul><p>A folyamatok kommunikációjának egyik legfontosabb megvizsgálandó területe az, hogy a megfelelő közös <span class="fogalom" title="erőforrás">erőforrások</span> (ilyen pl. a memória) használata során ne álljon elő olyan helyzet, hogy az egyik folyamat &#132;elrontja&#148; a másik folyamat ezen <span class="fogalom" title="erőforrás">erőforrás</span> -használatát például azzal, hogy az <span class="fogalom" title="erőforrás">erőforrás</span>t módosítja, miközben a másik folyamat még az <span class="fogalom" title="erőforrás">erőforrás</span> módosítás előtti értékével dolgozik, így ezáltal bizonytalan helyzetet teremt az <span class="fogalom" title="erőforrás">erőforrás</span> &#132;valódi&#148; értékével kapcsolatban.  </p><p>Azt, amikor kettő vagy több folyamat ír vagy olvas megosztott, közösen használt változókat, és a végeredmény (a közösen használt változók értéke is) csak attól függ, hogy melyik folyamat milyen időpillanatban fut le, illetve milyen időpillanatban használja ezeket az adatokat, versenyhelyzetnek nevezzük. Azokat az utasításokat, illetve azt a programrészt, amelyben a programunk a közös <span class="fogalom" title="erőforrás">erőforrást</span> használja, kritikus területnek, kritikus szekciónak vagy kritikus blokknak nevezzük. </p><p>Annak biztosítására, hogy a párhuzamosan működő folyamataink korrekten együttműködjenek, azaz ne alakuljon ki versenyhelyzet, az alábbi négy feltételnek kell teljesülni:</p><ul><li>egyidejűleg ne lehessen két folyamat a saját kritikus szekciójában;</li><li>ne legyen semmilyen előfeltétel a számítógép sebességéről, a processzorok számáról vagy a memória nagyságáról;</li><li>egyetlen kritikus szekcióján kívül lévő folyamat sem blokkolhat más folyamatokat;</li><li>egy folyamatnak sem kell örökké várnia arra, hogy a kritikus szekciójába tudjon lépni.</li></ul><p>A kölcsönös kizárás megvalósításához kétféle hardveres módszert használhatunk: a megszakítások tiltását, illetve a TSL utasítás segítségét. Szoftveres megoldásként használhatjuk például a szigorú váltogatás Peterson-féle megvalósítását.</p><p>Összességében elmondhatjuk, hogy mind a TSL utasításra támaszkodó, mind a Petersen-féle megoldás is jó, egyetlen apróságot leszámítva: mindkét megoldás tevékeny várakozással (ciklikus várakozással) tölti az idejét. Ez valójában azt jelenti, hogy a várakozó folyamat is processzoridőt követel, vagyis ezek a megoldások nem igazán hatékonyak.</p><p>Ahhoz, hogy a drága processzoridőt ne pazaroljuk, olyan megoldást lehet javasolni, ami vagy blokkolni tud egy folyamatot (aludni küld), vagy fel tudja azt ébreszteni ebből a blokkolt állapotból. A probléma tárgyalásához nézünk egy általános, gyakran előforduló feladatot, amit &#132;gyártó-fogyasztó&#148; problémaként is ismerünk. A helyes megoldáshoz, az osztott változó megfelelő kezelésére E. W. Dijkstra 1965-ben tett javaslatot. Vezessünk be egy egész változót, ezt nevezték el <span class="fogalom" title="szemafor">szemafornak</span>. A <span class="fogalom" title="szemafor">szemafor</span> olyan elemi műveletet biztosít az osztott adaton, amelyet nem lehet megszakítani. A kétállapotú <span class="fogalom" title="szemafor">szemafort</span> sok környezetben speciális névvel illetik, az angol kölcsönös kizárás kifejezésből <span class="fogalom" title="mutex">mutex</span> a neve. </p><p>Látjuk majd, hogy a <span class="fogalom" title="szemafor">szemaforok</span> jók, könnyen használhatók, de a használatuk nagy körültekintést igényel. Azért, hogy a hibamentes programok írását megkönnyítsék, Brinch Hansen (1973) és Charles Anthony Richard Hoare (1974) magasabb szintű nyelvű konstrukciót javasoltak, amelyet <span class="fogalom" title="monitor">monitornak</span> neveztek el. A <span class="fogalom" title="monitor">monitor</span> kicsit a mai osztálydefinícióra emlékeztet, eljárásokat, változókat és &#132;feltétel&#148; változót is tartalmazhat. A <span class="fogalom" title="monitor">monitornak</span> a legfontosabb tulajdonsága, hogy egy időpillanatban csak egy folyamat lehet aktív benne; a fejlesztési környezetektől függ, hogy ezt a feltételt hogyan biztosítja. A feltételváltozó tulajdonsága az, hogy rajtuk blokkoló, illetve ébresztő utasítás értelmezhető.</p><p>A kölcsönös kizárás teljesülése <span class="fogalom" title="osztott memória">osztott memória</span>, <span class="fogalom" title="szemafor">szemaforok</span> segítségével nem mindig megvalósítható. Kell egy másik módszer, éspedig a jelzések, az üzenetküldés lehetősége. </p><p>Két <span class="fogalom" title="rendszerhívás">rendszerhívást</span> definiálunk a szolgáltatás biztosítására: az egyik a &#132;send&#148;, a másik a &#132;receive&#148;. (Ezek elvi definíciók, a gyakorlatban egyes környezetekben más-más névre is hallgatnak. Ilyen például: a kill, a msg_snd vagy a msg_rcv. Később majd mutatunk példákat a használatukra.)</p><p>Az IPC világának számos, ehhez a témakörhöz tartozó problémafelvetése és elemzése is megtalálható. Befejezésül röviden két jól ismert feladat (étkező filozófusok esete, író-olvasók probléma) ismertetésével zárjuk a leckét.</p> 
    </div>
    <div class="kovetelmeny">
      <h2>Követelmény </h2>
      <p>A tanuló ismerje az IPC fogalmát, jellemzőit. Legyen ismerete a folyamatok kommunikációjának típusairól, a jelzésekről, az üzenetküldésről és a kölcsönös kizárás biztosításáról. Ismerje és legyen képes különbséget tenni a kölcsönös kizárás hardveres és szoftveres megoldásai között, illetve a tevékeny várakozás, a <span class="fogalom" title="szemafor">szemafor</span> használata és nem utolsósorban az üzenetküldés módszere között. Az IPC világában klasszikusnak számító termelő-fogyasztó problémáját ismerje, lássa a tevékeny várakozás, a <span class="fogalom" title="szemafor">szemafor</span> vagy akár az üzenetküldéssel megvalósított megoldások közti különbséget. Legyen képes alkalmazni ezen &#132;klasszikus megoldásokat&#148; konkrét fejlesztő környezetben. Ismerjen egy-két klasszikus IPC-problémát, azok megoldását.</p> 
    </div>
    <div class="feladatok">
      <h2>Önállóan megoldható feladatok</h2>
      <ul><li>Készítsen párhuzamos működés bemutatására egy szkriptfájlt! A program másodpercenként írja ki az aktuális időt a paraméterként megadott fájlba. Ezt annyi másodpercig végezze, amennyit második paraméterként megadunk. (Használja a sleep parancsot adott ideig történő várakozáshoz.) Az elkészült fájlt indítsa el többször a háttérben, majd az fg, bg parancsok segítségével cserélje le az előtérben futó programot egy háttérben futó programra. (A Ctrl + Z billentyű leütésére egy STOP szignált küldhetünk az éppen futó programnak.)</li><li>Az első feladatban elkészített szkriptfájl több példányát indítsa el a háttérben. Adjon nagyobb időparamétert a futtatás parancs kiadásánál. Egy adott azonosítóval (PID) rendelkező folyamatot vegyen az előtérbe, azaz ne a háttérben fusson, hanem az előtérben.</li><li>Készítse el a pék-vásárló probléma megoldását! Használja a Petersen-féle tevékeny várakozással megvalósított megoldást. A megoldás során használhat Unix operációs rendszer alatti, C vagy C++ programozási nyelvi fejlesztőrendszert, de ha jobban ismeri a Microsoft Windows operációs rendszer alatti fejlesztőkörnyezeteket, akkor akár a Microsoft Visual Studio fejlesztőkörnyezet egy tetszőleges programozási nyelve segítségével is elkészítheti a megoldást.</li><li>Készítse el a pék-vásárló probléma megoldását! Az előző feladattal ellentétben most használjon szemafort a megoldás során, vagy használja az üzenetküldés módszerét. A megoldás során használhat Unix operációs rendszer alatti, C vagy C++ programozási nyelvi fejlesztőrendszert, de ha jobban ismeri a Microsoft Windows operációs rendszer alatti fejlesztőkörnyezeteket, akkor akár a Microsoft Visual Studio fejlesztőkörnyezet egy tetszőleges programozási nyelve segítségével is elkészítheti a megoldást.</li><li>Készítse el az írók-olvasók probléma megoldását! Használjon szemafort a megoldás során, vagy használja az üzenetküldés módszerét! A megoldás során használhat Unix <span class="fogalom" title="operációs rendszer">operációs rendszer</span> alatti, C vagy C++ programozási nyelvi fejlesztőrendszert, de ha jobban ismeri a Microsoft Windows operációs rendszer alatti fejlesztőkörnyezeteket, akkor akár a Microsoft Visual Studio fejlesztőkörnyezet egy tetszőleges programozási nyelve segítségével is elkészítheti a megoldást.</li></ul> 
    </div>
  </div>
  <div class="tartalommenu">
    <div class="tartalommenu_fejlec"><span id="lapteteje"><a  href="#teteje"><span class="gyorsb">F</span>el a lap tetejére</a></span><a name="fejezetek"   id="fejezetek">Tartalomjegyzék</a></div>
    <ul><li><a href="#hiv1">A párhuzamosság alapjai &ndash; folyamatok kommunikációja, versenyhelyzetek, kritikus szekciók, szemaforok, monitorok és szignálok</a><ul><li><a href="#hiv2">A folyamatok párhuzamosságának, kommunikációjának alapjai</a></li></ul></li></ul> 
  </div>
  <div class="tartalom"> <a name="tartalom" id="tartalom"></a> 
    <h1><a name="hiv1" id="hiv1" ></a>A párhuzamosság alapjai &ndash; folyamatok kommunikációja, versenyhelyzetek, kritikus szekciók, szemaforok, monitorok és szignálok</h1><h2><a name="hiv2" id="hiv2" ></a>A folyamatok párhuzamosságának, kommunikációjának alapjai</h2><p>Ahogy az előző (ötödik) leckében (&#132;Folyamatok, folyamatleírók, táblázatok és <span class="fogalom" title="szál">szálak</span> fogalma. A folyamat <span class="fogalom" title="szál">szálak</span> közötti különbségek&#148;) is láttuk, a mai <span class="fogalom" title="operációs rendszer">operációs rendszerek</span> majdnem mindegyike a többfeladatos, <span class="fogalom" title="multiprogramozás">multiprogramozásos</span> modellt használja. Ez azt jelenti, hogy az <span class="fogalom" title="operációs rendszer">operációs rendszer</span> nyilvántartja az éppen &#132;futó&#148; folyamatokat, és gondoskodik arról, hogy ezek szép sorban végrehajtódjanak, biztosítva azt, hogy minden folyamatról úgy érezzük: &#132;folyamatosan&#148; működik. </p><p>Ebben az esetben néha látszatpárhuzamosságról is beszélünk, különösen akkor, amikor egy processzor (<span class="fogalom" title="CPU">CPU</span>) van a rendszerben, megkülönböztetve ezt attól az esettől, amikor többmagos processzorral kiépített számítógépet használunk, netalán ebből nem is egyet. Ekkor a magok valódi párhuzamos működést mutatnak, ugyanazt a fizikai memóriát használva. Ebben a modellben a folyamatok <span class="fogalom" title="párhuzamosság">párhuzamosságának</span> alapja az, hogy a folyamatok egy szekvenciális végrehajtási sorrá alakulnak. Ezekbe a folyamatokba beleértjük az <span class="fogalom" title="operációs rendszer">operációs rendszer</span> rendszerfolyamatait is. </p><p>A folyamatok működése során gyakran előfordul, hogy egyik folyamatnak a helyes működéséhez szüksége van egy másik folyamat valamilyen közreműködésére. A legegyszerűbb ilyen eset az adatcsövön (avagy <span class="fogalom" title="csővezeték">csővezetéken</span>) keresztül összekapcsolt parancsok végrehajtása során áll elő. Például nézzük az alábbi parancsot:</p><p><span class="forraskod">who | wc &ndash;l</span></p><p>Ez a parancssorozat megadja, hogy aktuálisan hány felhasználó van az <span class="fogalom" title="operációs rendszer">operációs rendszerben</span> bejelentkezve olyan módon, hogy a &#132;who&#148; parancs kimenetét a &#132;wc&#148; parancs bemenetére rakjuk (A példa a <span class="fogalom" title="UNIX">UNIX</span> -szerű <span class="fogalom" title="operációs rendszer">operációs rendszereken</span> működik, amilyen például a <span class="fogalom" title="GNU/LINUX">GNU/LINUX</span> <span class="fogalom" title="operációs rendszer">operációs rendszer</span> is.) Ezt végzi el az adatcsövön (avagy <span class="fogalom" title="csővezeték">csővezetéken</span>) keresztül az <span class="fogalom" title="operációs rendszer">operációs rendszer</span>.</p><p>Az iménti példa is a folyamatok kommunikációjának egy esetét mutatja. A folyamatok kommunikációját gyakran rövidíti a szakirodalom az &#132;IPC&#148; kifejezéssel, ami az InterProcess Communication kifejezés rövidítése.</p><p>Ezzel kapcsolatban három területet kell megvizsgálni, illetve a következő lehetőségeket kell biztosítani:</p><ul><li>Egy folyamat hogyan tud információt küldeni egy másik folyamatnak. Például az iménti adatcsöves parancskapcsolásnál a <strong>wc</strong> parancs addig várakozik, amíg az előző <strong>who</strong> parancs nem végzett a végrehajtással. Amikor a &#132;who&#148; parancs végrehajtása befejeződött (azaz megkaptuk a bejelentkezett felhasználókat), küldeni kell az <span class="fogalom" title="operációs rendszer">operációs rendszernek</span> egy üzenetet erről az eseményről a &#132;wc&#148; parancsnak, így az megkezdheti a működését.</li><li>Biztosítani kell, hogy kettő vagy több folyamat ne keresztezze egymás útját, azaz ne ugyanazt a tevékenységet akarják végrehajtani egyszerre.</li><li>Biztosítani kell a megfelelő (helyes) sorrendben történő feladat-végrehajtást. (Meg kell tudni várni egy másik folyamat befejeződését.)</li></ul><p>Az utóbbi két terület a <span class="fogalom" title="szál">szálakra</span> (szálkezelésre) is ugyanúgy vonatkozik, mint a folyamatokra. Az első terület, az információküldés a <span class="fogalom" title="szál">szálak</span> esetében nem igényel különösebb vizsgálatot, hiszen a <span class="fogalom" title="szál">szálak</span> egy folyamaton belül egy címtartományban vannak, és ezen belül például egy egyszerű változó állításával tudnak információt cserélni. Később nem is hangsúlyozzuk, hogy <span class="fogalom" title="szál">szálakról</span> is beszélhetünk, hiszen a problémák azokra is vonatkoznak.</p><p>A folyamatok közti kommunikáció gyakori esete az, amikor egy folyamat egy másik befejezésére vár. Ebben a helyzetben &ndash; és ez a tipikus &ndash; egy folyamat elindít egy másikat, majd bizonyos tevékenység után meg kell várnia, amíg a másik elindított folyamat befejeződik. </p><p><strong>Példa: egy program hogyan tud egy másik programot, esetleg önmagát meghívni</strong></p><p>Röviden tekintsük át azt a példát, hogy egy program hogyan tud egy másik programot, esetleg önmagát meghívni, elindítani! Önmagunkat úgymond &#132;megduplázni&#148; a fork <span class="fogalom" title="rendszerhívás">rendszerhívással</span> tudjuk. A &#132;fork&#148; <span class="fogalom" title="rendszerhívás">rendszerhívásnak</span> paramétere nincs, visszatérési értékéből következtethetünk arra, hogy egyrészt sikeres volt-e egyáltalán a <span class="fogalom" title="rendszerhívás">rendszerhívás</span> (azaz az értéke nem negatív), illetve arra, hogy ha a visszatérési érték nulla, akkor a &#132;fork&#148; <span class="fogalom" title="rendszerhívás">rendszerhívással</span> létrehozott gyerekfolyamatban vagyunk, különben ha pozitív az érték, akkor a szülőfolyamatban vagyunk.</p><div class="forraskod"><div class="bekezdes1cm">

#include &lt;iostream.h&gt; 
void main() { 
     int a, b; 
     a = fork(); 
     if (a &lt; 0) { 
          cerr &lt;&lt; "A fork hivas sikertelen!\n&#148;; 
          exit(1); 
     }; 
     if (a) { 
          cout &lt;&lt;"Hello, ez a szolo!\n"; 
          cout &lt;&lt;&#148;A gyerekem pid-je: " &lt;&lt; a &lt;&lt; &rsquo;\n&rsquo;; 
          cout &lt;&lt;"Most varakozik a wait....\n"; 
          wait(&#38;b); 
          cout&lt;&lt;"Most van vege a szulo varakozasanak...\n"; 
     } else { 
          cout &lt;&lt;"Ez a gyerek processz! \n&#148;; 
          cout &lt;&lt;&#148;Billentyuleutesre varunk...\n"; 
          getchar(); 
          cout &lt;&lt;"Es ezzel a kiirassal a gyerek processz le is fut...\n"; 
          exit(0); 
     }; 
}
</div>
</div><p>Mielőtt kicsit megnéznénk a fenti példa működését, az időközben előjött <strong>wait</strong> hívást kell megmagyaráznunk. A wait hívás addig várakozik, amíg a várakozás befejezését előidéző <span class="fogalom" title="szignál">szignál</span>t (pl. SIGKILL) nem kap, vagy amíg a gyerekfolyamat be nem fejezi a futását. A wait hívás így mindig a szülőfolyamatban kerül meghívásra. A wait hívásnak egy egész típusú mutató (pointer) a paramétere, amiben a gyerekfolyamat exit státuszát kapjuk vissza. A wait hívás eredményül adja vissza annak a gyereknek az azonosítóját, amelyik befejeződésének hatására a wait hívás visszatér. (Megjegyzés: ezt az előbbi példában nem használtuk ki!)</p><p>A példában így arról van szó, hogy a <strong>fork</strong> <span class="fogalom" title="rendszerhívás">rendszerhívással</span> létrehozunk egy gyerekfolyamatot, ami ebben az esetben néhány kiíráson kívül nem csinál mást, csak egy karakter beolvasásra vár. A szülőfolyamat a wait hívásig szintén csinál kiírásokat, a szükséges tevékenységét itt elvégzi, majd várakozik arra, hogy a gyereke befejezze a működését!</p><p>Hasznosak lehetnek még a <strong>getpid</strong>(), a <strong>getppid</strong>(), illetve a <strong>setpgrp</strong>() <span class="fogalom" title="rendszerhívás">rendszerhívások</span>, amelyek közül a getpid és a getppid <span class="fogalom" title="rendszerhívás">rendszerhívások</span> rendre a folyamat azonosítóját és a szülőfolyamat azonosítóját adják vissza. A setpgrp <span class="fogalom" title="rendszerhívás">rendszerhívás</span> a folyamat csoportazonosítóját, a folyamatazonosítóra állítja be. Hasznos lehet ezeken kívül még a <strong>kill </strong><span class="fogalom" title="rendszerhívás">rendszerhívás</span>. A kill <span class="fogalom" title="rendszerhívás">rendszerhívásnak</span> két paramétere van: az első a folyamatazonosítóval megcímzett folyamatnak vagy folyamatoknak elküldi a második paraméterként megadott <span class="fogalom" title="szignál">szignált</span>. Ezt a <span class="fogalom" title="rendszerhívás">rendszerhívást</span> később pontosabban is megnézzük.</p><p class="vissza"><a href="#fejezetek">Vissza a tartalom<span class="gyorsb">j</span>egyzékhez</a></p> 
  </div>
</div>
<div class="utmutato_also">
  <div class="utm_hivatkozasok_also"><a class="oldalteteje" accesskey="f" href="#teteje"><span class="gyorsb">F</span>el a lap tetejére</a>
  <a class="elozotanlap" id="navialsoelozo" href="teszt/lecke5/teszt.html"><img src="navi/ikon_elozolap.gif" alt="Ugrás a tananyag előző oldalára" title="Ugrás a tananyag előző oldalára" width="36" height="36" /></a>
  <a id='navialsokov' class="kovetktanlap" href="lecke6_lap2.html"><img src="navi/ikon_kovetklap.gif" alt="Ugrás a tananyag következő oldalára" title="Ugrás a tananyag következő oldalára" width="36" height="36"/></a>
  </div>
</div>
<div class="ki_stilus"></div>
<div class="impresszum">
  <table class="uszt">
    <tr>
      <td><div class="imp_eltetatklogo"><img alt="ELTE és ELTE TáTK logó" src="css/arculat/elte_plus_tatk.png" style="width:100%;height:auto;" /></div>
        <div class="imp_elteiklogo"><img alt="ELTE és ELTE IK logó" src="css/arculat/elte_plus_ik.png" style="width:100%;height:auto;" /></div></td>
      <td><div class="imp_uszt"><img alt="Új Széchenyi terv" src="css/arculat/USZT_logo_cmyk.jpg" style="width:100%;height:auto;" /></div></td>
      <td><div class="imp_eu"><img alt="A projekt az Európai Unió támogatásával, az Európai Szociális Alap társfinanszirozásával valósul meg." title="A projekt az Európai Unió támogatásával, az Európai Szociális Alap társfinanszirozásával valósul meg." src="css/arculat/ESZA.png" style="width:100%;height:auto;"/></div></td>
    </tr>
  </table>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="hu" lang="hu">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="css/scormelte_alap.css" rel="stylesheet" type="text/css" title="" />
<link href="css/style_spec.css" rel="stylesheet" type="text/css" />
<link href="css/scormelte_nagy.css" rel="alternate stylesheet" type="text/css" title="nagy" />
<link href="css/scormelte_inverz.css" rel="alternate stylesheet" type="text/css" title="inverz" />
<!--[if lte IE 6]>
<link href="css/scormelte_ie6.css" rel="stylesheet" type="text/css" title="" />
<![endif]-->
<!-- syntax highlight -->
<link rel="stylesheet" type="text/css" href="css/shCore.css" />
<link rel="stylesheet" type="text/css" href="css/shThemeDefault.css" />
<script type="text/javascript" src="js/shCore.js"></script>
<script type="text/javascript" src="js/shBrushCpp.js"></script>
<script type="text/javascript" src="js/shBrushCSharp.js"></script>
<script type="text/javascript" src="js/shBrushDelphi.js"></script>
<script type="text/javascript" src="js/shBrushXml.js"></script>
<script type="text/javascript" src="js/shBrushCss.js"></script>
<script type="text/javascript" src="js/shBrushJScript.js"></script>
<script type="text/javascript" src="js/shBrushSql.js"></script>
<script type="text/javascript">
SyntaxHighlighter.all()
</script>
<title>
Számítógépes alapismeretek II. / 
Az <span class="fogalom" title="erőforrás">erőforrások</span> fogalma és kezelése, input és output <span class="fogalom" title="ütemezés">ütemezések</span>, a <span class="fogalom" title="holtpont">holtpont</span> fogalma és kezelése, illetve az alapvető holtpontkezelő algoritmusok
/Az alapvető holtpontkezelési stratégiák </title>
<meta name="description" content="A tananyag  fejlesztése a TÁMOP-4.1.2.A/2-10/1 pályázat keretén belül történt." />
<meta name="keywords" content="Hardver alapismeretek, operációs rendszer, számítógépes alapismeretek, operációs rendszer fogalma, operációs rendszerek története, operációs rendszer feladata, operációs rendszer generációk, operációs rendszer típusok, folyamatok, folyamat táblázat, szál &ndash; folyamatok, rendszerhívások, operációs rendszer struktúrák, kernelmód, kernel, felhasználói mód, B/K művelet, folyamatok modellje, szinkron rendszerhívás, asszinkron rendszerhívás, állapotai, megvalósításuk, folyamatok kommunikációja, IPC (Inter Process Communication), megszakítástábla, IDT, megszakításvezérlő, PIC, megszakítás, interrupt, megszakításkérelem, IRQ, megszakításkezelési folyamat, kivétel, hibakeresés (debuggolás), töréspont, fájlrendszer, MBR, partíciós szektor, Ntldr, klaszter (cluster), szektor, FAT, NTFS, ext, TSS, csapda, ütemezés, szál, szemafor, mutex, monitor, POSIX, szignál, osztott memória, csővezeték, kritikus szakasz, Wybe Dijkstra, CPU, erőforrás, holtpont, kiéheztetés, integrált áramkör, multiprogramozás, beágyazott rendszerek, partíció, MMU, lapcsere, FIFO, socket, lapozás, swap, interaktív rendszer, kötegelt rendszer, kliens, job, jogosultság, metaadat, könyvtár, UNIX, GNU/LINUX, erőforrás-foglalási gráf, fizikai memória, virtuális memória, merevlemez, floppy, fregmentáció, defregmentáló program, MFT, API, i-node, cache memory, SSH, HyperThread, párhuzamosság" />
<script type="text/javascript" src="js/jquery-1.3.2.min.js"></script>
<script type="text/javascript" src="js/kep.js"></script>
<script type="text/javascript" src="js/jquery.media.js"></script>
<script type="text/javascript" src="js/jquery.highlight-3.js"></script>
<script type="text/javascript" src="js/kereses.js"></script>
<script type="text/javascript" src="js/stylesheetToggle.js"></script>
<script type="text/javascript" src="js/cookie.js"></script>
<script type="text/javascript" src="js/stilusvalto.js"></script>
<script type="text/javascript" src="js/fogalmak.js"></script>
<script type="text/javascript" src="js/fogalom.js"></script>
<script type="text/javascript" src="js/jwplayer.js"></script>
<script type="text/javascript">
$(document).ready(function() 
{
$("a.hang").media( {width: 250, height: 50,  autoplay: false} );
});
</script>
<script type="text/javascript" src="js/navigacio.js"></script>
</head>
<body>
<div><a name="teteje"  id="teteje"></a></div>
<div class="jawsfmenu">
  <ul>
    <li><a class="tartalom" href="#tartalom" accesskey="t" tabindex="2">Ugrás a <span class="gyorsb">t</span>artalomra</a></li>
    <li><a class="tartalomj" href="#fejezetek" accesskey="j" tabindex="5">Ugrás a tartalom<span class="gyorsb">j</span>egyzékre</a></li>
    <li><a class="tanutm" href="#tanutm" accesskey="u" tabindex="7">Ugrás a tan<span class="gyorsb">u</span>lási útmutatóra</a></li>
  </ul>
</div>
<div class="ki_kereses"></div>
<div class="oldal">
  <div class="utmutato">
    <div class="utm_hivatkozasok"><span class="elozolap"><img src="navi/ikon_vissza_dis.gif" alt="Vissza az előzőleg látogatott oldalra (nem elérhető funkció)" title="Vissza az előzőleg látogatott oldalra (nem elérhető funkció)" /></span><a class="kezdolap" href="index.html" accesskey="p" tabindex="21"><img src="navi/ikon_kezdolap.gif" alt="Vissza a modul kezdőlapjára" title="Vissza a modul kezdőlapjára" width="36" height="36"/></a><a class="elozotanlap" href="lecke9_lap5.html" accesskey="e" tabindex="22"><img src="navi/ikon_elozolap.gif" alt="Ugrás a tananyag előző oldalára" title="Ugrás a tananyag előző oldalára" width="36" height="36" /></a><a class="kovetktanlap" href="teszt/lecke9/teszt.html" accesskey="v" tabindex="23"><img src="navi/ikon_kovetklap.gif" alt="Ugrás a tananyag következő oldalára" title="Ugrás a tananyag következő oldalára" width="36" height="36"/></a><span class="ki_fogalomkapcs"><img src="navi/ikon_fogalmakbe_dis.gif" alt="Fogalom megjelenítés (nem elérhető funckió)" title="Fogalom megjelenítés (nem elérhető funckió)" /></span><span class="ki_fogalomlista"><img src="navi/ikon_fogalmaklista_dis.gif" alt="Fogalmak listája (nem elérhető funkció)" title="Fogalmak listája (nem elérhető funkció)" /></span><span class="ki_nyomtatas"><img src="navi/ikon_nyomtatas_dis.gif" alt="Oldal nyomtatása (nem elérhető funkció)" title="Oldal nyomtatása (nem elérhető funkció)" /></span><a class="oldalterkep" href="oldalterkep.html" accesskey="d" tabindex="31"><img src="navi/ikon_oldalterkep.gif" alt="Oldaltérkép megtekintése" title="Oldaltérkép megtekintése"  width="36" height="36" /></a><a class="sugo" href="sugo.html" accesskey="s" tabindex="33"><img src="navi/ikon_sugo.gif" alt="Súgó megtekintése" title="Súgó megtekintése"  width="36" height="36" /></a></div>
  </div>
  <div class="tartalommenu">
    <div class="tartalommenu_fejlec"><span id="lapteteje"><a  href="#teteje"><span class="gyorsb">F</span>el a lap tetejére</a></span><a name="fejezetek"   id="fejezetek">Tartalomjegyzék</a></div>
    <ul><li><a href="#hiv1">Az erőforrások fogalma és kezelése, input és output ütemezések, a holtpont fogalma és kezelése, illetve az alapvető holtpontkezelő algoritmusok</a><ul><li><a href="#hiv2">Az alapvető holtpontkezelési stratégiák </a><ul><li><a href="#hiv3">A holtpontok megelőzése </a></li><li><a href="#hiv4">A holtpontok elkerülése </a></li><li><a href="#hiv5">Holtpont-elkerülési algoritmusok </a><ul><li><a href="#hiv6">A strucc algoritmus </a></li><li><a href="#hiv7">Egyetlen foglalási lehetőség stratégia (one-shot allocation strategy) </a></li><li><a href="#hiv8">Rangsor szerinti foglalási stratégia (hierarchical allocation strategy) </a></li><li><a href="#hiv9">A bankár algoritmus (Banker&rsquo;s algorithm) </a></li></ul></li></ul></li></ul></li></ul> 
  </div>
  <div class="tartalom"> <a name="tartalom"    id="tartalom"></a> 
    <h1><a name="hiv1" id="hiv1"></a>Az erőforrások fogalma és kezelése, input és output ütemezések, a holtpont fogalma és kezelése, illetve az alapvető holtpontkezelő algoritmusok</h1><h2><a name="hiv2" id="hiv2"></a>Az alapvető holtpontkezelési stratégiák </h2><h3><a name="hiv3" id="hiv3"></a>A holtpontok megelőzése </h3><p>Ahogyan a <span class="fogalom" title="holtpont">holtpontok</span> kialakulásának a feltételeinél is megjegyeztük, a <span class="fogalom" title="holtpont">holtpont</span> kialakulását úgy előzhetjük meg, hogy törekszünk az olyan eset elkerülésére, amikor a <span class="fogalom" title="holtpont">holtpontok</span> kialakulásának összes felsorolt feltétele egyszerre áll fenn. Tehát egy használható módszer az, ha úgy ütemezzük a különböző rendelkezésre álló <span class="fogalom" title="erőforrás">erőforrásokat</span>, hogy a feltételek közül legalább az egyik ne teljesüljön. </p><p>A <span class="fogalom" title="holtpont">holtpont</span> kialakulásához szükséges feltételek elkerülése: </p><ul><li>A <strong>kölcsönös kizárás </strong>néhány esetben elkerülhetetlen, így ezekben az esetekben nem lehet mit csinálni, de más esetekben elkerülhető. Az egyik leggyakrabban használt technika az úgynevezett <strong>spooling</strong> technika (simultaneous peripherial operation on-line), ami annyit teszt, hogy a direkt erőforrás-használat helyett egy általában nagyméretű átmeneti tárolóba helyezzük az <span class="fogalom" title="erőforrás">erőforrást</span>. </li><li>Az<strong> </strong><span class="fogalom" title="erőforrás"><strong>erőforrások</strong></span><strong> lefoglalása</strong> úgy kerülhető el, ha elrendeljük azt, hogy egyszerre csak egy <span class="fogalom" title="erőforrás">erőforrást</span> foglalhat le egy folyamat, tehát egy folyamat csak akkor igényelhet egy új <span class="fogalom" title="erőforrás">erőforrást</span>, ha nem birtokol már egy másik <span class="fogalom" title="erőforrás">erőforrást</span>. Ez megoldható úgy, ha a folyamat a futás során lefoglalt <span class="fogalom" title="erőforrás">erőforrást</span> a következő erőforrás-igénylés előtt felszabadítja. </li><li>A <strong>&#132;megszakítás nem megengedett&#148;</strong> kiküszöbölése, azaz hogy nincs erőszakos erőforrás-elvétel, a következő módon érhető el: hogyha az <span class="fogalom" title="erőforrás">erőforrásaink</span> menthető állapotúak, akkor elvehetjük az adott folyamattól az <span class="fogalom" title="erőforrás">erőforrás</span> birtoklásának jogát úgy, hogy mentjük az <span class="fogalom" title="erőforrás">erőforrás</span> állapotát, majd az <span class="fogalom" title="erőforrás">erőforrást</span> átadjuk a másik folyamatnak, és mikor a másik folyamat befejezte a működését, akkor az <span class="fogalom" title="erőforrás">erőforrás</span> régebbi állapotát visszaállítva visszaadjuk az <span class="fogalom" title="erőforrás">erőforrást</span> az előző folyamatnak. </li><li>A <strong>visszatérő igények</strong> elkerülése úgy érhető el, hogy kialakítunk egy hierarchikus rendszert. Az <span class="fogalom" title="erőforrás">erőforrásokat</span> kategorizáljuk, és hozzájuk prioritásokat rendelünk. Ez után minden folyamat csak olyan <span class="fogalom" title="erőforrás">erőforrásokat</span> igényelhet, amelyeknek a prioritása nagyobb, mint amilyen <span class="fogalom" title="erőforrás">erőforrásai</span> már vannak. </li></ul><p>Tehát ha a fenti négy feltételből legalább az egyik kialakulását meg tudjuk akadályozni, nem fog kialakulni <span class="fogalom" title="holtpont">holtpont</span>. A feltételek közül az első, illetve a harmadik feltétellel nem tudunk mit kezdeni, mivel az <span class="fogalom" title="operációs rendszer">operációs rendszerünkben</span> vagy vannak a feltételek által megállapított fajtájú <span class="fogalom" title="erőforrás">erőforrások</span>, vagy nincsenek. </p><p class="vissza"><a href="#fejezetek">Vissza a tartalom<span class="gyorsb">j</span>egyzékhez</a></p><h3><a name="hiv4" id="hiv4"></a>A holtpontok elkerülése </h3><p>A <span class="fogalom" title="holtpont">holtpontok</span> kialakulását nemcsak megelőzéssel tudjuk meggátolni, hanem még elkerüléssel is. Az elkerülés abban nyilvánul meg, hogy az <span class="fogalom" title="operációs rendszer">operációs rendszer</span> minden egyes erőforrás-igénylés előtt készít egy kiértékelést arra vonatkozóan, hogy ha az adott folyamat erőforrás-igénylését kielégíti, az vezethet-e valamilyen holtponthelyzetre. </p><p>Ha a kiértékelés révén az <span class="fogalom" title="operációs rendszer">operációs rendszer</span> arra jut, hogy ha a folyamat <span class="fogalom" title="erőforrás">erőforrás</span> igényét kielégítené, és az <span class="fogalom" title="holtpont">holtpontra</span> vezet, akkor nem fogja a folyamat erőforrás-igénylését kielégíteni, hanem várakozásra fogja kényszeríteni a biztonságos (holtpontmentes) állapot fenntartása érdekében. Ekképpen előfordulhat az is, hogy az <span class="fogalom" title="operációs rendszer">operációs rendszer</span> még akkor sem elégíti ki a folyamat erőforrásigényét, ha az látszólag nem indokolt (pl. van elég sok szabad <span class="fogalom" title="erőforrás">erőforrás</span>). </p><p>Tehát az <span class="fogalom" title="operációs rendszer">operációs rendszer</span> a <span class="fogalom" title="holtpont">holtpontok</span> elkerülésével védi a biztonságos, azaz holtpontmentes állapotát úgy, hogy folyamatosan figyeli a folyamatok erőforrás-igénylését. Ez egy futási idejű figyelés, elemzés. </p><p>Az egyetlen nyitott kérdés most már csak az, hogy ha az <span class="fogalom" title="operációs rendszer">operációs rendszer</span> a <span class="fogalom" title="holtpont">holtpontok</span> elkerülésére törekszik, az általa végzett kiértékelést milyen algoritmussal végzi el? Tehát milyen algoritmus szerint dönti el azt, hogy ha az adott folyamat erőforrás-igénylését kielégíti-e, azaz a folyamat erőforrásigénye vezethet-e valamilyen holtponthelyzetre, vagy sem. </p><p class="vissza"><a href="#fejezetek">Vissza a tartalom<span class="gyorsb">j</span>egyzékhez</a></p><h3><a name="hiv5" id="hiv5"></a>Holtpont-elkerülési algoritmusok </h3><h4><a name="hiv6" id="hiv6"></a>A strucc algoritmus </h4><p>A strucc algoritmus a &#132;struccpolitika&#148; elvét vallja, aminek egyszerűen a lényege az, hogy nem veszünk tudomást a <span class="fogalom" title="holtpont">holtpont</span> létezéséről. Ha tudjuk azt, hogy egy esetleges <span class="fogalom" title="holtpont">holtpont</span> kialakulásának valószínűsége meglehetősen kicsi, és az <span class="fogalom" title="operációs rendszer">operációs rendszer</span> újraindításának nincsenek kritikus következményei, akkor előfordulhat, hogy érdemes ezt a &#132;megoldást&#148; választani, mint <span class="fogalom" title="holtpont">holtpont</span> &#132;elkerülő&#148; algoritmust. </p><p><em>Előnyök: </em></p><ul><li>Gyors holtpontelkerülés. </li></ul><p><em>Hátrányok: </em></p><ul><li>Adatvesztés, a folyamatok végeredményeinek elvesztése fennállhat. </li><li><span class="fogalom" title="holtpont">holtpontok</span> megléte: mivel az algoritmus szerint csak figyelmen kívül hagyjuk a <span class="fogalom" title="holtpont">holtpontokat</span>, azaz a holtponthelyzeteket, azok ugyanúgy ott lesznek, és maguktól nem fognak köddé válni. </li><li>Kritikus következmények esetleges megléte. </li><li>Nem ajánlott, mivel ez csak egy &#132;struccpolitika&#148;. </li></ul><h4><a name="hiv7" id="hiv7"></a>Egyetlen foglalási lehetőség stratégia (one-shot allocation strategy) </h4><p>Az egyetlen foglalási lehetőség stratégia lényege az, hogy megtiltja a várakozás közben fellépő erőforrás-lekötést, azaz csak az a folyamat igényelhet magának <span class="fogalom" title="erőforrás">erőforrást</span>, amelyiknek egy erőforrásigénye sincs. </p><p>A stratégia alkalmazása esetén egy folyamat csak egyetlen alkalommal, általában a folyamat induláskor foglalhatja le azokat az <span class="fogalom" title="erőforrás">erőforrásokat</span>, amelyekre szüksége van a futása során. A stratégia alkalmat ad arra ezáltal, hogy ha a folyamat indulásakor van olyan <span class="fogalom" title="erőforrás">erőforrás</span>, amelyet a folyamat nem tud lefoglalni (tehát az adott <span class="fogalom" title="erőforrás">erőforrás</span> éppen nem szabad), akkor az <span class="fogalom" title="operációs rendszer">operációs rendszer</span> a folyamatot várakozásra kényszeríti, és így egy úgynevezett várakozási listára kerül fel. Ezen felül a stratégia még elrendeli azt is, hogy mivel egyetlen alkalommal foglalhatja le csak a folyamat a szükséges <span class="fogalom" title="erőforrás">erőforrásokat</span>, így a futása során más alkalommal nem nyújthat már be erőforrásigényt az <span class="fogalom" title="operációs rendszer">operációs rendszer</span> felé, és ha van is erőforrás-igénylése, akkor az <span class="fogalom" title="operációs rendszer">operációs rendszer</span> elutasítja, mivel már rendelkezik <span class="fogalom" title="erőforrás">erőforrásokkal</span>. </p><p><span class="fogalom" title="holtpont">holtpont</span> nem alakulhat ki az <span class="fogalom" title="operációs rendszer">operációs rendszernek</span> a futó folyamatai között, mivel a futó folyamatok minden <span class="fogalom" title="erőforrás">erőforrást</span> elérhetnek, amikre szükségük volt már a futásuk elején, mert ha valamilyen <span class="fogalom" title="erőforrás">erőforrás</span> megléte (birtoklása) hiányozna, akkor nem futó folyamatok lennének, hanem a várakozási listában várakoznának, illetve ezek a várakozó folyamatok nem rendelkeznek semmilyen <span class="fogalom" title="erőforrás">erőforrás</span> használatával. </p><p><em>Előnyök: </em></p><ul><li><span class="fogalom" title="holtpont">holtpont</span> nem alakulhat ki a stratégia használata esetén. </li><li>Ha egy folyamat már megszerezte az összes olyan <span class="fogalom" title="erőforrás">erőforrást</span>, ami a futásához szükséges, akkor biztosan nem kell sohasem várakoznia a futása során esetleges erőforrás-használat megszerzésére, így a folyamat futási idejét semmilyen <span class="fogalom" title="erőforrás">erőforrásra</span> való várakozás nem fogja megzavarni, meghosszabbítani. </li></ul><p><em>Hátrányok: </em></p><ul><li>A folyamatoknak a futásuk végéig kell birtokolniuk a futásuk kezdetekor szükségessé vált <span class="fogalom" title="erőforrás">erőforrásokat</span>, tehát akkor is, ha nincsen rá semmilyen szükségük. Eszerint ez egy nagyon pazarló stratégia. </li><li>Nem mérhető fel minden esetnem egy folyamat erőforrásigénye már a futás kezdetekor. </li><li><span class="fogalom" title="kiéheztetés">kiéheztetés</span> lehetséges fennállása: ha egy folyamat nagyon sok <span class="fogalom" title="erőforrás">erőforrást</span> igényel, akkor előfordulhat, hogy nem mindegyik elérhető a futásának az elején, így lehetséges az, hogy beláthatatlan ideig várakozásra kényszeríti az <span class="fogalom" title="operációs rendszer">operációs rendszer</span> a folyamatot, így egyszerűen kiéheztetve az <span class="fogalom" title="erőforrás">erőforrásokra</span> vonatkozóan. </li></ul><h4><a name="hiv8" id="hiv8"></a>Rangsor szerinti foglalási stratégia (hierarchical allocation strategy) </h4><p>A rangsor szerinti foglalási stratégia a ciklikus várakozási lehetőségét küszöböli ki azzal, hogy az <span class="fogalom" title="erőforrás">erőforrásokat</span> úgy kategorizálja, hogy minden egyes kategóriához egy-egy sorszámot rendel, és a leggyakrabban használt <span class="fogalom" title="erőforrás">erőforráshoz</span> a legkisebb sorszámot rendeli, míg a legritkábban használt <span class="fogalom" title="erőforrás">erőforráshoz</span> pedig a legnagyobb sorszámot, így felállítva közöttük egy úgynevezett prioritási sorrendet. </p><p>A rangsor szerinti foglalási stratégia lényege a prioritási sorrend megkonstruálása által az, hogy a különböző folyamatok mindig csak növekvő sorszámú <span class="fogalom" title="erőforrás">erőforrást</span> igényelhetnek az <span class="fogalom" title="operációs rendszer">operációs rendszertől</span>, azaz egy folyamat mindig csak magasabb sorszámú <span class="fogalom" title="erőforrás">erőforrást</span> igényelhet meg az <span class="fogalom" title="operációs rendszer">operációs rendszertől</span>, mint amilyen sorszámú prioritást már birtokol. Így a stratégia alkalmassá válik a holtponthelyzetek elkerülésére. </p><p>Továbbá, ha egy folyamatnak a meglévő <span class="fogalom" title="erőforrás">erőforrásainak</span> sorszámainál alacsonyabb sorszámú <span class="fogalom" title="erőforrás">erőforrásra</span> van szüksége, akkor fel kell szabadítania a szükséges <span class="fogalom" title="erőforrás">erőforrás</span> sorszámánál nagyobb sorszámú <span class="fogalom" title="erőforrás">erőforrásokat</span> egészen addig, míg a folyamat erőforrás-igénylési feltételei (lényegében a rangsor szerinti foglaláis stratégia feltételei) nem teljesülnek. </p><p><em>Előnyök: </em></p><ul><li><span class="fogalom" title="holtpont">holtpont</span> nem alakulhat ki a stratégia használata esetén. </li><li>Nagyon hatékony, ha a megfelelő módon történt a sorszámok kiosztása az <span class="fogalom" title="erőforrás">erőforrásoknak</span>. </li></ul><p><em>Hátrányok: </em></p><ul><li>Ha nem megfelelő módon történik a sorszámok kiosztása az <span class="fogalom" title="erőforrás">erőforrásoknak</span>, akkor nem biztosítható a stratégia hatékonysága. </li><li>Problémás eset, ha a folyamatnak a meglévő <span class="fogalom" title="erőforrás">erőforrásai</span> sorszámainál alacsonyabb sorszámú <span class="fogalom" title="erőforrás">erőforrásra</span> van szüksége. </li></ul><h4><a name="hiv9" id="hiv9"></a>A bankár algoritmus (Banker&rsquo;s algorithm) </h4><p>Edsger Wybe Dijkstra-tól származik az egyik holtpontelkerülő <span class="fogalom" title="ütemezés">ütemezési</span> algoritmus, amit bankár algoritmusnak is nevezünk. </p><p>Az algoritmus neve onnan származik, hogy a probléma nagymértékben hasonló a bankárok munkájához, azaz általánosabban tekintve a bankok erőforrás-kihelyezési problémájához. A hitelt igénylő ügyfelek a bankárhoz fordulnak a beruházásaik finanszírozásához szükséges hitelekért. A bankár az ügyfelek egy meghatározott (a hitelt kérő ügyfeleknek) csoportjával foglalkozik, akiknek folyósít egy bizonyos mennyiségű hitelt. A hiteligénylők a bankárnak megmondják, hogy pontosan mennyi lenne az a maximális pénzmennyiség, amire szükségük lehet, és a bankár ezt folyósítja számukra. Természetesen a bankár nem rendelkezik végtelen mennyiségű készpénzzel, így nem rendelkezik annyi pénzzel sem, ami az összes ügyfél teljes hiteligényét kielégítené egy időpontban. A hitelt csak az az ügyfél tudja visszafizetni, aki be is tudja fejezni a beruházását, amihez a hitelt igényelte eredetileg, ám a beruházás befejezéséhez szüksége van arra, hogy előbb vagy utóbb hozzáférhessen az igényelt hitel teljes pénzösszegéhez. A bankár tudja, hogy nem mindegyik ügyfélnek lesz szüksége azonnal a maximális hitelre, és feltételezi, hogy minden ügyféle a teljes hitel felvételét követően, amint csak tudja, azonnal vissza is fizeti a hitelt. </p><p>A hitelt csak az az ügyfél tudja visszafizetni, aki be tudta fejezni a beruházást; ehhez pedig szüksége van arra, hogy előbb-utóbb hozzájusson az igényelt hitel teljes összegéhez. </p><p>Ha a bankár nem elég óvatosan bánik a pénzével, akkor könnyen &#132;megnézheti magát&#148;, mivel kiürülhet a pénzes kasszája, és egyik ügyféle sem fejezné be a beruházását, mivel nem lenne egyiküknek sem pénze, amiből gazdálkodhatna, és folytathatná a beruházást, vagy akár törlessze a hitelt, mert nem kapná meg a hitelének a következő részét. </p><p>Az algoritmus pontosan azt adja meg, hogy hogyan kell eljárnia a bankárnak az előbb említett (<span class="fogalom" title="holtpont">holtpont</span>) helyzetek elkerülésére, feltételezve, hogy csak önmagára számíthat, és nincsen semmilyen segítsége, amire számíthatna? </p><p>A bankár algoritmus lényege tehát az, hogy az <span class="fogalom" title="operációs rendszer">operációs rendszert</span> mindig egy biztonságos állapotban tartja. A biztonságos állapot a bankár algoritmus esetében azt jelenti, hogy létezik legalább egy olyan erőforrás-igénylés kielégíthetőségi sorrend, amely szerint minden egyes folyamat erőforrás-igénylése kielégíthető. Tehát létezik olyan állapotsorozat, amelynek eredményeként mindegyik ügyfél felvehet összesen annyi kölcsönt, amennyit a hitel lehetősége enged, azaz minden folyamat megkapja az összes <span class="fogalom" title="erőforrás">erőforrását</span>, majd a tevékenysége után befejeződik. Az algoritmus sohasem elégít ki egy olyan erőforrás-igénylést sem, amely által az <span class="fogalom" title="operációs rendszer">operációs rendszer</span> biztonságos állapota nem állna fenn. </p><p>A bankár algoritmus csak akkor működik, ha a folyamatok már az indulásukkor tudják, hogy a különböző <span class="fogalom" title="erőforrás">erőforrásokból</span> egyszerre maximálisan mennyit fognak igényelni, illetve ezt az <span class="fogalom" title="operációs rendszer">operációs rendszernek</span> be is jelentik. </p><p>Ha az <span class="fogalom" title="operációs rendszer">operációs rendszer</span> állapota nem biztonságos, még nem jelenti azt, hogy a <span class="fogalom" title="holtpont">holtpont</span> biztosan kialakul, hanem mindössze csak annyit jelent, hogy <em>lehetséges</em> <span class="fogalom" title="holtpont">holtpont</span> kialakulása az adott állapotból. A bankár algoritmus úgy garantálja a holtpontmentességet, hogy már a nem biztonságos állapot kialakulását is megakadályozza, tehát a túlzott biztonságot tartja szem előtt. A módszer legnagyobb hátrányának tekinthető, hogy léteznek olyan folyamatok, amelyeknek erőforrásigénye előre nem ismerhető fel. </p><p>A bankár algoritmus minden egyes erőforrás-igénylés megjelenésekor elemzést végez, és megnézi, hogy vajon az erőforrás-igénylés engedélyezése esetén is biztonságos marad-e a rendszer. Ha igen, akkor a kérést jóváhagyja, ha nem, akkor a kérést későbbre halasztja. Egy állapot biztonságosságának eldöntésekor a bankár azt elemzi, hogy van-e elegendő <span class="fogalom" title="erőforrás">erőforrása</span> ahhoz, hogy kielégítse néhány ügyfél hiteligényét. Ha ezt meg tudja tenni, akkor természetesen feltételezi, hogy az ügyfelek a kölcsönöket vissza fogják fizetni, és következhet annak az ügyfélnek a vizsgálata, akinek a hitelfolyósításainak összege a legközelebb van az általa igényelhető maximális hitelmennyiségnek, és így tovább. Ha az ügyfelek minden kölcsönt visszafizetnek a bankárnak, akkor az állapot biztonságos, és a kezdeti <span class="fogalom" title="erőforrás">erőforrás</span> igénylését a folyamatnak ki lehet elégíteni.</p><p class="vissza"><a href="#fejezetek">Vissza a tartalom<span class="gyorsb">j</span>egyzékhez</a></p> 
  </div>
</div>
<div class="utmutato_also">
  <div class="utm_hivatkozasok_also"><a class="oldalteteje" accesskey="f" href="#teteje"><span class="gyorsb">F</span>el a lap tetejére</a>
  <a class="elozotanlap" id="navialsoelozo" href="lecke9_lap5.html"><img src="navi/ikon_elozolap.gif" alt="Ugrás a tananyag előző oldalára" title="Ugrás a tananyag előző oldalára" width="36" height="36" /></a>
  <a id='navialsokov' class="kovetktanlap" href="teszt/lecke9/teszt.html"><img src="navi/ikon_kovetklap.gif" alt="Ugrás a tananyag következő oldalára" title="Ugrás a tananyag következő oldalára" width="36" height="36"/></a>
  </div>
</div>
<div class="ki_stilus"></div>
<div class="impresszum">
  <table class="uszt">
    <tr>
      <td><div class="imp_eltetatklogo"><img alt="ELTE és ELTE TáTK logó" src="css/arculat/elte_plus_tatk.png" style="width:100%;height:auto;" /></div>
        <div class="imp_elteiklogo"><img alt="ELTE és ELTE IK logó" src="css/arculat/elte_plus_ik.png" style="width:100%;height:auto;" /></div></td>
      <td><div class="imp_uszt"><img alt="Új Széchenyi terv" src="css/arculat/USZT_logo_cmyk.jpg" style="width:100%;height:auto;" /></div></td>
      <td><div class="imp_eu"><img alt="A projekt az Európai Unió támogatásával, az Európai Szociális Alap társfinanszirozásával valósul meg." title="A projekt az Európai Unió támogatásával, az Európai Szociális Alap társfinanszirozásával valósul meg." src="css/arculat/ESZA.png" style="width:100%;height:auto;"/></div></td>
    </tr>
  </table>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="hu" lang="hu">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="css/scormelte_alap.css" rel="stylesheet" type="text/css" title="" />
<link href="css/style_spec.css" rel="stylesheet" type="text/css" />
<link href="css/scormelte_nagy.css" rel="alternate stylesheet" type="text/css" title="nagy" />
<link href="css/scormelte_inverz.css" rel="alternate stylesheet" type="text/css" title="inverz" />
<!--[if lte IE 6]>
<link href="css/scormelte_ie6.css" rel="stylesheet" type="text/css" title="" />
<![endif]-->
<!-- syntax highlight -->
<link rel="stylesheet" type="text/css" href="css/shCore.css" />
<link rel="stylesheet" type="text/css" href="css/shThemeDefault.css" />
<script type="text/javascript" src="js/shCore.js"></script>
<script type="text/javascript" src="js/shBrushCpp.js"></script>
<script type="text/javascript" src="js/shBrushCSharp.js"></script>
<script type="text/javascript" src="js/shBrushDelphi.js"></script>
<script type="text/javascript" src="js/shBrushXml.js"></script>
<script type="text/javascript" src="js/shBrushCss.js"></script>
<script type="text/javascript" src="js/shBrushJScript.js"></script>
<script type="text/javascript" src="js/shBrushSql.js"></script>
<script type="text/javascript">
SyntaxHighlighter.all()
</script>
<title>
Számítógépes alapismeretek II. / 
Folyamatok, folyamatleírók, táblázatok és <span class="fogalom" title="szál">szálak</span> fogalma. A folyamatok és a <span class="fogalom" title="szál">szálak</span> közötti különbségek, a folyamatok <span class="fogalom" title="ütemezés">ütemezése</span>
/A folyamatok ütemezésének, azaz az ütemezési algoritmusoknak a csoportosítása</title>
<meta name="description" content="A tananyag  fejlesztése a TÁMOP-4.1.2.A/2-10/1 pályázat keretén belül történt." />
<meta name="keywords" content="Hardver alapismeretek, operációs rendszer, számítógépes alapismeretek, operációs rendszer fogalma, operációs rendszerek története, operációs rendszer feladata, operációs rendszer generációk, operációs rendszer típusok, folyamatok, folyamat táblázat, szál &ndash; folyamatok, rendszerhívások, operációs rendszer struktúrák, kernelmód, kernel, felhasználói mód, B/K művelet, folyamatok modellje, szinkron rendszerhívás, asszinkron rendszerhívás, állapotai, megvalósításuk, folyamatok kommunikációja, IPC (Inter Process Communication), megszakítástábla, IDT, megszakításvezérlő, PIC, megszakítás, interrupt, megszakításkérelem, IRQ, megszakításkezelési folyamat, kivétel, hibakeresés (debuggolás), töréspont, fájlrendszer, MBR, partíciós szektor, Ntldr, klaszter (cluster), szektor, FAT, NTFS, ext, TSS, csapda, ütemezés, szál, szemafor, mutex, monitor, POSIX, szignál, osztott memória, csővezeték, kritikus szakasz, Wybe Dijkstra, CPU, erőforrás, holtpont, kiéheztetés, integrált áramkör, multiprogramozás, beágyazott rendszerek, partíció, MMU, lapcsere, FIFO, socket, lapozás, swap, interaktív rendszer, kötegelt rendszer, kliens, job, jogosultság, metaadat, könyvtár, UNIX, GNU/LINUX, erőforrás-foglalási gráf, fizikai memória, virtuális memória, merevlemez, floppy, fregmentáció, defregmentáló program, MFT, API, i-node, cache memory, SSH, HyperThread, párhuzamosság" />
<script type="text/javascript" src="js/jquery-1.3.2.min.js"></script>
<script type="text/javascript" src="js/kep.js"></script>
<script type="text/javascript" src="js/jquery.media.js"></script>
<script type="text/javascript" src="js/jquery.highlight-3.js"></script>
<script type="text/javascript" src="js/kereses.js"></script>
<script type="text/javascript" src="js/stylesheetToggle.js"></script>
<script type="text/javascript" src="js/cookie.js"></script>
<script type="text/javascript" src="js/stilusvalto.js"></script>
<script type="text/javascript" src="js/fogalmak.js"></script>
<script type="text/javascript" src="js/fogalom.js"></script>
<script type="text/javascript" src="js/jwplayer.js"></script>
<script type="text/javascript">
$(document).ready(function() 
{
$("a.hang").media( {width: 250, height: 50,  autoplay: false} );
});
</script>
<script type="text/javascript" src="js/navigacio.js"></script>
</head>
<body>
<div><a name="teteje"  id="teteje"></a></div>
<div class="jawsfmenu">
  <ul>
    <li><a class="tartalom" href="#tartalom" accesskey="t" tabindex="2">Ugrás a <span class="gyorsb">t</span>artalomra</a></li>
    <li><a class="tartalomj" href="#fejezetek" accesskey="j" tabindex="5">Ugrás a tartalom<span class="gyorsb">j</span>egyzékre</a></li>
    <li><a class="tanutm" href="#tanutm" accesskey="u" tabindex="7">Ugrás a tan<span class="gyorsb">u</span>lási útmutatóra</a></li>
  </ul>
</div>
<div class="ki_kereses"></div>
<div class="oldal">
  <div class="utmutato">
    <div class="utm_hivatkozasok"><span class="elozolap"><img src="navi/ikon_vissza_dis.gif" alt="Vissza az előzőleg látogatott oldalra (nem elérhető funkció)" title="Vissza az előzőleg látogatott oldalra (nem elérhető funkció)" /></span><a class="kezdolap" href="index.html" accesskey="p" tabindex="21"><img src="navi/ikon_kezdolap.gif" alt="Vissza a modul kezdőlapjára" title="Vissza a modul kezdőlapjára" width="36" height="36"/></a><a class="elozotanlap" href="lecke5_lap4.html" accesskey="e" tabindex="22"><img src="navi/ikon_elozolap.gif" alt="Ugrás a tananyag előző oldalára" title="Ugrás a tananyag előző oldalára" width="36" height="36" /></a><a class="kovetktanlap" href="teszt/lecke5/teszt.html" accesskey="v" tabindex="23"><img src="navi/ikon_kovetklap.gif" alt="Ugrás a tananyag következő oldalára" title="Ugrás a tananyag következő oldalára" width="36" height="36"/></a><span class="ki_fogalomkapcs"><img src="navi/ikon_fogalmakbe_dis.gif" alt="Fogalom megjelenítés (nem elérhető funckió)" title="Fogalom megjelenítés (nem elérhető funckió)" /></span><span class="ki_fogalomlista"><img src="navi/ikon_fogalmaklista_dis.gif" alt="Fogalmak listája (nem elérhető funkció)" title="Fogalmak listája (nem elérhető funkció)" /></span><span class="ki_nyomtatas"><img src="navi/ikon_nyomtatas_dis.gif" alt="Oldal nyomtatása (nem elérhető funkció)" title="Oldal nyomtatása (nem elérhető funkció)" /></span><a class="oldalterkep" href="oldalterkep.html" accesskey="d" tabindex="31"><img src="navi/ikon_oldalterkep.gif" alt="Oldaltérkép megtekintése" title="Oldaltérkép megtekintése"  width="36" height="36" /></a><a class="sugo" href="sugo.html" accesskey="s" tabindex="33"><img src="navi/ikon_sugo.gif" alt="Súgó megtekintése" title="Súgó megtekintése"  width="36" height="36" /></a></div>
  </div>
  <div class="tartalommenu">
    <div class="tartalommenu_fejlec"><span id="lapteteje"><a  href="#teteje"><span class="gyorsb">F</span>el a lap tetejére</a></span><a name="fejezetek"   id="fejezetek">Tartalomjegyzék</a></div>
    <ul><li><a href="#hiv1">Folyamatok, folyamatleírók, táblázatok és szálak fogalma. A folyamatok és a szálak közötti különbségek, a folyamatok ütemezése</a><ul><li><a href="#hiv2">Programozási környezet</a><ul><li><a href="#hiv3">A folyamatok ütemezésének, azaz az ütemezési algoritmusoknak a csoportosítása</a><ul><li><a href="#hiv4">Kötegelt rendszerek ütemezése</a></li><li><a href="#hiv5">Az interaktív rendszerek ütemezése</a></li><li><a href="#hiv6">A valós idejű rendszerek ütemezése</a></li></ul></li><li><a href="#hiv7">A szálak ütemezése</a></li></ul></li></ul></li></ul> 
  </div>
  <div class="tartalom"> <a name="tartalom"    id="tartalom"></a> 
    <h1><a name="hiv1" id="hiv1"></a>Folyamatok, folyamatleírók, táblázatok és szálak fogalma. A folyamatok és a szálak közötti különbségek, a folyamatok ütemezése</h1><h2><a name="hiv2" id="hiv2"></a>Programozási környezet</h2><h3><a name="hiv3" id="hiv3"></a>A folyamatok ütemezésének, azaz az ütemezési algoritmusoknak a csoportosítása</h3><p>A különböző igények, ahogy láttuk, más-más váltási módszert kívánnak, így az <span class="fogalom" title="ütemezés">ütemezési</span> algoritmusok is annak megfelelően csoportosíthatók, hogy milyen rendszerekről is van szó. Ezért megkülönböztetjük az alábbi <span class="fogalom" title="ütemezés">ütemezési</span> csoportokat:</p><ul><li>kötegelt,</li><li>interaktív,</li><li>valós idejű.</li></ul><p>Az <span class="fogalom" title="ütemezés">ütemezési</span> algoritmusoktól minden környezetben elvárjuk, hogy pártatlanok, illetve a kiválasztott elveket és a rendszeregyensúlyt megtartók legyenek. </p><p><span class="fogalom" title="kötegelt rendszer">kötegelt rendszerekben</span> (bár ezek ma már ritkábban használatosak, és nagy, drága rendszerek), fontos a processzor- (<span class="fogalom" title="CPU">CPU</span>-) kihasználtság, az egységnyi idő alatt végrehajtott feladatok száma. </p><p><span class="fogalom" title="interaktív rendszer">interaktív rendszerekben</span> (ilyenek a mai <span class="fogalom" title="operációs rendszer">operációs rendszereink</span>), a legfontosabb a felhasználói elvárásoknak való megfelelés és a kérésekre adott gyors válasz. </p><p>Valós idejű rendszerekben (ezekből sincs olyan sok a mai hétköznapi környezetünkben), a legfontosabb követelmény az, hogy a megfelelően előírt határidőket (válaszokat, reakciókat) be kell tartani, hiszen ettől valós idejű a rendszerünk.</p><h4><a name="hiv4" id="hiv4"></a>Kötegelt rendszerek ütemezése</h4><p>Általában a manapság használatos <span class="fogalom" title="operációs rendszer">operációs rendszerünk</span> nem tartozik a &#132;<span class="fogalom" title="kötegelt rendszer">kötegelt rendszerek</span>&#148; világába, mégis érdemes röviden megemlíteni ezeknek a rendszernek legjellemzőbb <span class="fogalom" title="ütemezés">ütemezési</span> típusait. Négy fontosabb <span class="fogalom" title="ütemezés">ütemezést</span> különböztetünk meg ebben a világban:</p><ul><li>sorrendi <span class="fogalom" title="ütemezés">ütemezés</span>,</li><li>&#132;legrövidebb feladat először&#148; <span class="fogalom" title="ütemezés">ütemezés</span>,</li><li>&#132;legrövidebb maradék futási idejű&#148; <span class="fogalom" title="ütemezés">ütemezés</span>,</li><li>háromszintű <span class="fogalom" title="ütemezés">ütemezés</span>.</li></ul><p><strong>A sorrendi ütemezés</strong></p><p>Az <span class="fogalom" title="ütemezés">ütemezések</span> közül talán a legegyszerűbb a sorrendi <span class="fogalom" title="ütemezés">ütemezés</span>. A futásra kész folyamatok egy várakozó sorban helyezkednek el. A sorban levő első folyamatot hajtja végre a központi egység. Ha befejeződik a folyamat végrehajtása, az ütemező a sorban következő feladatot veszi elő. Ha az <span class="fogalom" title="operációs rendszer">operációs rendszerbe</span> új feladatok érkeznek, azok a sor végére kerülnek. Ha az aktuálisan futó folyamat blokkolódik, akkor a sorban következő folyamat jön, míg a blokkolt folyamat, ha újra futásra kész lesz, akkor a sor végére kerül, és majd idővel újra rá kerül a vezérlés. </p><p>Ez az algoritmus egyszerű, és könnyű is alkalmazni, ám egy hátránya van: a sok input/output igényű folyamatok minden adatírás vagy adatolvasás során blokkolódnak, majd a sor végére kerülnek, így túl lassan futnak le az összes számításigényű folyamatokhoz képest. </p><p><strong>A &#132;legrövidebb feladat először&#148; ütemezés</strong></p><p>Az elnevezésből is következik, hogy a folyamatok végrehajtási sorrendje azok futási idejével kapcsolatos. Az <span class="fogalom" title="ütemezés">ütemezés</span> elve szerint az a folyamat kerül először <span class="fogalom" title="ütemezés">ütemezésre</span>, amelyiknek a legkisebb a futási ideje. </p><p>Az <span class="fogalom" title="ütemezés">ütemezés</span> az alkalmazhatóság szempontjából nem ideális, ha nem tudjuk előre a folyamatok végrehajtási idejét. Ennek a meghatározása, ha nem is volt nagyon lehetetlen feladat a <span class="fogalom" title="kötegelt rendszer">kötegelt rendszerekben</span>, azért nem is volt mindig lehetséges. (Ahogy egy mai <span class="fogalom" title="operációs rendszer">operációs rendszerben</span> is inkább nehezebb ezt meghatározni, szinte sokszor csak következtetni lehet.)</p><p><strong>A &#132;legrövidebb maradék futási idejű&#148; ütemezés</strong></p><p>Ennél az <span class="fogalom" title="ütemezés">ütemezésnél</span> is ismerni kell a folyamatok futási idejét előre. Amikor új folyamat érkezik, vagy a blokkolás miatt egy következő folyamathoz kerül a vezérlés, akkor nem a teljes folyamat végrehajtási idejét, hanem csak a hátralévő időt vizsgálja az ütemező, és amelyik folyamatnak legkisebb a maradék futási ideje, az kerül <span class="fogalom" title="ütemezés">ütemezésre</span>.</p><p><strong>A háromszintű ütemezés</strong></p><p>Az <span class="fogalom" title="ütemezés">ütemezés</span> alatt általában (és manapság is) azt értjük, hogy a központi egység milyen sorrendben, azaz milyen elv alapján kap egy feladatot végrehajtásra. A háromszintű <span class="fogalom" title="ütemezés">ütemezésben</span> is létezik ez, és ezt <strong>processzorütemezési szintnek</strong> (<span class="fogalom" title="CPU">CPU</span> <span class="fogalom" title="ütemezés">ütemezési</span> szintnek) hívjuk. </p><p>A feladatok a központi memóriában vannak, közülük egyet hajt végre a központi egység. Előfordulhat, hogy a többi feladat közül ki kell rakni egyet a háttértárba, mivel a működés során elfogyhat a memória. Ezt az <span class="fogalom" title="ütemezés">ütemezést</span> a <strong>memóriaütemezési szintnek</strong> nevezzük. </p><p>Az a döntést, hogy a futásra jelentkező folyamatok milyen sorrendben kerüljenek be a memóriába, a bebocsátó ütemező hozza meg. Ezt az <span class="fogalom" title="ütemezés">ütemezést</span> a <strong>bebocsátó </strong><span class="fogalom" title="ütemezés"><strong>ütemezési</strong></span><strong> szintnek</strong> nevezzük. </p><p>Az <em>5.8. ábra</em> a három szint összekapcsolódását mutatja.</p><!--fej5_kep_8--><div class="kep kozep sz650"><img src="kepek/fej5_kep8_w650.jpg" alt="Az 5.8. ábra a három szint összekapcsolódását mutatja." style="width:100%; height:auto;" title="Az 5.8. ábra a három szint összekapcsolódását mutatja." /><span class="kepalairas">5.8. ábra: A háromszintű ütemezés kapcsolata</span></div><div class="uresmargo"></div><!--ENDfej5_kep_8--><p>A mai <span class="fogalom" title="interaktív rendszer">interaktív rendszerekben</span> a memóriaütemező feladatát a memóriakezeléshez szokták sorolni, és a <span class="fogalom" title="CPU">CPU</span>, azaz a központi egység <span class="fogalom" title="ütemezés">ütemezését</span> értjük folyamatok <span class="fogalom" title="ütemezés">ütemezésén</span>. </p><p>A bebocsátó <span class="fogalom" title="ütemezés">ütemezésnek</span> nincs megfelelője, hiszen elég furcsa <span class="fogalom" title="interaktív rendszer">interaktív rendszerről</span> beszélhetnénk, ha a feladat indulása nem azonnal, annak kiadásának pillanatában történne meg.</p><h4><a name="hiv5" id="hiv5"></a>Az interaktív rendszerek ütemezése</h4><p>Az interaktív <span class="fogalom" title="operációs rendszer">operációs rendszerek</span> körében több processzorütemezési algoritmus ismert, a legfontosabbakat az alábbiakban áttekintjük.</p><p><strong>A round-robin ütemezés</strong></p><p>Ez az egyik legismertebb, legrégebbi és legpártatlanabb <span class="fogalom" title="ütemezés">ütemezés</span> az <span class="fogalom" title="interaktív rendszer">interaktív rendszerek</span> világában. Az ütemező beállít egy időzítő segítségével egy időintervallumot, és az időzítő <span class="fogalom" title="megszakítás">megszakítást</span> ad minden egyes esetben, amikor lejárt a beállított idő. Ez egy hardverelem-szolgáltatás, mint egy speciális jelzőóra, ami, mondjuk, 10 percenként jelez. Természetesen a mai számítógépek esetében nem 10 perces intervallumról van szó, hanem általában 10&ndash;30 ezredmásodpercről. Általában igaz, hogy ha túl kicsi intervallumot állít be az ütemező, akkor gyakran kapja meg a <span class="fogalom" title="megszakítás">megszakítás</span> miatt a vezérlést, ezzel &#132;elaprózza&#148; az <span class="fogalom" title="operációs rendszer">operációs rendszer</span> teljesítményét, ami nem igazán hatékony. Ha túl nagy intervallumot adunk meg, akkor pedig a sok input/output igénnyel fellépő folyamatok <span class="fogalom" title="ütemezés">ütemezése</span> nem lesz túlságosan hatékony, dinamikus. Persze tudható, hogy mindenki számára tökéletes megoldás nem létezik, de azért minden rendszer igyekszik egy &#132;arany középutat&#148; találni, ami ma körülbelül 20 ezredmásodperc körül van.</p><p>Tehát a megadott időközönként az óra<span class="fogalom" title="megszakítás">megszakítás</span> bekövetkezik, és ekkor az ütemező a következő folyamatnak adja a processzort. A folyamatokat egy sorban tárolja a rendszer, és amikor lejárt az időszelet, akkor az a folyamat, amelyiktől az ütemező éppen elveszi a vezérlést, a sor végére kerül. Ha egy aktuális működő folyamat az időszelete lejárta előtt blokkolódik vagy véget ér, akkor is megtörténik a központi egység átadása.</p><p><strong>A prioritásos ütemezés</strong></p><p>Az előző round-robin <span class="fogalom" title="ütemezés">ütemezés</span> egyszerűsége és nagyszerűsége mellett felmerül az az igény, hogy nem feltétlenül egyformán fontos minden egyes folyamat. Például egy felhasználói folyamat (mondjuk, egy remek játék) a felhasználónak talán a legfontosabb, míg egy nyomtatási sort kezelő folyamatnál nem nagy baj, ha csak ritkábban kapja meg a vezérlést. Ez a megfontolás vezetett oda, hogy a folyamatokhoz egy fontossági mérőszámot, prioritást rendeljenek hozzá. Ennek figyelembevételével született meg a prioritásos <span class="fogalom" title="ütemezés">ütemezés</span>.</p><p>A prioritások figyelembevétele sokféleképpen történhet. Például úgynevezett &#132;prioritási osztályokat&#148; hozhatunk létre. Az <span class="fogalom" title="ütemezés">ütemezés</span> módszere az alábbi lehet. </p><p>Futtassuk a legmagasabb osztályban lévő folyamatokat round-robin módon, majd ha ezek elfogytak, akkor az alacsonyabb osztálybeli folyamatokat szépen sorban! Ez a módszer jó, csak sajnos fennáll annak a veszélye, hogy az alacsonyabb osztályban lévő folyamatok akár éhen is halhatnak! Emiatt tisztán ezt a módszert ritkán használják, szükség van a prioritások &#132;igazítására&#148;. Ilyen igazítás lehet az például, amikor egy folyamat, ha lejárt az időszelete és nem fejeződött be, akkor egy prioritási osztállyal lejjebb kerül. Olyan módosítás is elképzelhető, amikor az egyes prioritási osztályokhoz rövidebb vagy hosszabb időszeletet rendelünk hozzá. Például a legmagasabb osztályhoz egy időszeletet, az alatta lévőhöz kettőt, és így tovább. Ezt a módosítást többszörös sorok bevezetésével tudjuk biztosítani, így gyakran találkozhatunk ezzel az elnevezéssel is.</p><p><strong>A &#132;legrövidebb folyamat következzen&#148; ütemezés</strong></p><p>A <span class="fogalom" title="kötegelt rendszer">kötegelt rendszerekben</span> használt módszer hasznos lehet interaktív környezetben is. Tehát ebben a felfogásban a leggyorsabban befejeződő folyamatot ütemezzük. Egyetlen gond az, hogy nem tudjuk, hogy melyik a folyamatok közül a leghamarabb befejeződő. Erre ezért becslést alkalmazunk, a múltbeli viselkedése alapján. </p><p>Az első futási időt jelöljük <em>T</em>1-gyel, a következő időt <em>T</em>2-vel, és vegyünk egy <em>x</em>-szel jelölt, egynél kisebb súlyértéket. Ekkor a következő becsült (avagy súlyozott) futási időt tételezzük fel harmadszorra:</p><!--fej5_kep_9--><div class="kep kozep sz100"><img src="kepek/fej5_kep9_w100.jpg" alt="A képen a becsült futási idő képlete látható: x * T1 + (1-x) * T2" style="width:100%; height:auto;" title="A képen a becsült futási idő képlete látható: x * T1 + (1-x) * T2" /><span class="kepalairas"></span></div><div class="uresmargo"></div><!--ENDfej5_kep_9--><p>Látható, hogy ha <em>x</em> értéke nulla közeli, akkor gyorsan elfelejtjük a régi értékeket, azaz a <em>T</em>1 szerepe a <em>T</em>3 megadásában kicsi lesz, míg ha az <em>x</em> értéke egy közeli, akkor nehezen felejtünk, azaz <em>T</em>1 szerepe <em>T</em>3 megadásában nagy lesz. </p><p>Ezt a folyamatot &#132;öregedésnek&#148; is nevezik, ahol az öregedés mértéke az <em>x</em>. Könnyű megvalósítani azt az esetet, ahol az öregedés mértéke 1/2, hiszen itt biteltolással (1 bittel jobbra) elvégezhető az időigényes szorzás művelet.</p><p><strong>A garantált ütemezés</strong></p><p>Ez az <span class="fogalom" title="ütemezés">ütemezés</span> egy kicsit más szemléletű a korábbiakhoz képest. Ígéretet teszünk, és garantáljuk, hogy ha mondjuk, <em>N</em> folyamat van a rendszerben, akkor egy folyamat körülbelül a teljes processzoridő 1/N részét kapja meg. (Egy egyfelhasználós rendszerben az <em>N</em> jelentse a párhuzamosan működő folyamatok számát.) Ehhez nyilván kell tartanunk a már felhasznált processzoridőt, majd ennek ismeretében kell egy felhasználónak (illetve az ő folyamatainak) rendszeridőt biztosítani. Az ütemező mindig a legkisebb arányszámú folyamatot fogja futtatni addig, amíg ez az arány meg nem haladja egyik &#132;versenytársáét&#148;.</p><p><strong>A sorsjáték-ütemezés</strong></p><p>Az iménti garantált <span class="fogalom" title="ütemezés">ütemezés</span> világos és egyszerű módszerénél kicsit komplikáltabb a sorsjátéknak a megvalósítása. A sorsjáték-<span class="fogalom" title="ütemezés">ütemezés</span> annyiban módosítja a garantált <span class="fogalom" title="ütemezés">ütemezés</span> által adott processzor- (<span class="fogalom" title="CPU">CPU</span>-) arány biztosítását, hogy ebben a folyamatok a megfelelő arányban sorsjegyeket kapnak a processzorütemezéshez. Az időintervallum lejáratakor sorsjegyet húz az ütemező, és amelyik folyamatnál van a sorsjegy, az kapja a végrehajtási jogot. Egy húzás után az adott folyamat természetesen elveszti a húzott sorsjegyet. </p><p>Látható, hogy amilyen arányban birtokolják a folyamatok a sorsjegyeket, pontosan olyan arányban jutnak processzoridőhöz is. A fontosabb folyamatok több sorsjegyet kapnak (magasabb prioritás), így nagyobb eséllyel (hamarabb) kapnak processzoridőt. Egy új folyamat megjelenésekor könnyű kezelni a helyzetet: kap valahány sorjegyet, és megy az <span class="fogalom" title="ütemezés">ütemezés</span> tovább. A sorsjáték-ütemezéssel adott arányú <span class="fogalom" title="erőforrás">erőforrás</span> biztosítása nagyon egyszerű: például egy videokiszolgáló esetén ha egy nagy és egy kis felbontású video-adatfolyam egységnyi adataránya mondjuk 3:1, akkor az ehhez szükséges erőforrástöbbletet ilyen arányú sorsjegyosztással megoldhatjuk.</p><p><strong>Az arányos ütemezés</strong></p><p>Az eddigi <span class="fogalom" title="ütemezés">ütemezési</span> megoldások során igazából folyamatokról és azok <span class="fogalom" title="ütemezés">ütemezéséről</span> beszéltünk. Sok esetben érdekes lehet ezen finomítani, hiszen ha egy élelmes felhasználó sok folyamatot elindít, akkor majdhogynem kisajátítja a teljes processzoridőt. Tekintve, hogy ez nem mindig szerencsés, vegyük figyelembe azt, hogy ki éppen egy adott folyamatnak a tulajdonosa. Ekkor például a sorsjáték-ütemezésnél egy felhasználó kap egy adott arányú sorsjegycsomagot, és ezen osztoznak a folyamatai. Ha sok folyamatot indít el, vagy éppen keveset, az nem számít, de azok összes sorsjegye nem változik.</p><h4><a name="hiv6" id="hiv6"></a>A valós idejű rendszerek ütemezése</h4><p>A valós idejű rendszerek kulcsa az idő. Ahogy láttuk korábban, az <span class="fogalom" title="ütemezés">ütemezési</span> algoritmusok pedig pontosan arról szólnak, hogy adott idő eltelte után ki legyen a következő futó. Ezek esetében is kulcsszerepe van az időnek. Egy <span class="fogalom" title="operációs rendszer">operációs rendszerben</span>, ha a feladatainknak nemcsak azt szabjuk meg, hogy hajtódjanak végre valamilyen korrekt <span class="fogalom" title="ütemezés">ütemezés</span> szerint, hanem az is egy kritérium, hogy egy adott kérést valamilyen időn belül ki kell szolgálni, akkor valós idejű <span class="fogalom" title="operációs rendszer">operációs rendszerről</span> beszélünk. Ezeket két kategóriába sorolhatjuk. </p><p><strong>Szigorú valós idejű</strong> (hard real-time) <strong>rendszerben</strong> a határidő betartása kötelező, <strong>toleráns valós idejű</strong> (soft real-time) <strong>rendszerben</strong> a határidők kis mulasztása még elfogadható, tolerálható. </p><p>A megfelelő határidők betartása úgy valósítható meg, hogy egy programot több folyamatra bontunk, és ezeknek a rövid (vagy rövidebb) folyamatoknak az ütemező biztosítja a számukra előírt határidő (vagy határidők) betartását. Ha a folyamatoknak egységnyi idő alatt <em>N</em> eseményük van, amelyek elvégzéséhez szükséges összes idő több mint egy, akkor az ilyet kezelhetetlenek tekintjük. Ha az összes idő kisebb, mint egy, akkor a valós idejű rendszer ütemezhető.</p><p class="vissza"><a href="#fejezetek">Vissza a tartalom<span class="gyorsb">j</span>egyzékhez</a></p><h3><a name="hiv7" id="hiv7"></a>A szálak ütemezése</h3><p>Röviden szóljunk befejezésül a <span class="fogalom" title="szál">szálak</span> <span class="fogalom" title="ütemezés">ütemezéséről</span>. Két esetről beszélhetünk a <span class="fogalom" title="szál">szálak</span> <span class="fogalom" title="ütemezés">ütemezésével</span> kapcsolatban. </p><p>A felhasználói szintű <span class="fogalom" title="szál">szálakról</span> az <span class="fogalom" title="operációs rendszer">operációs rendszer</span> nem tud, így ebben az esetben az alkalmazás tud mindenről, akár arról is, hogy egy <span class="fogalom" title="szál">szál</span> elhasználja a folyamat teljes idejét, és a többi <span class="fogalom" title="szál">szál</span> pedig csak várakozik. Az ilyen <span class="fogalom" title="szál">szál</span> önző viselkedése nem érinti a többi folyamatot, csakis a <span class="fogalom" title="szál">szál</span> folyamatát, és esetlegesen a meglévő &#132;testvér&#148; <span class="fogalom" title="szál">szálait</span>.</p><p>A <span class="fogalom" title="kernel">kernel</span> rendszerhívásszintű <span class="fogalom" title="szál">szálakról</span> az <span class="fogalom" title="operációs rendszer">operációs rendszer</span> tud, és gyakorlatilag egyenrangúan kezeli azokat a folyamatokkal, tehát minden <span class="fogalom" title="szál">szál</span> részt vesz az <span class="fogalom" title="ütemezés">ütemezési</span> folyamatban. Ebben az esetben a <span class="fogalom" title="szál">szálak</span> közti kapcsolás gyakorlatilag a folyamatok közti kapcsolással azonos <span class="fogalom" title="erőforrás">erőforrást</span> igényel, és pontosan az a helyzet, mint a korábbi <span class="fogalom" title="ütemezés">ütemezési</span> algoritmusoknál.</p><p>A felhasználói szálváltás, amit nem is az ütemező végez, ehhez képest gyors, hiszen nem kell környezetváltást végezni, de ezt az <span class="fogalom" title="ütemezés">ütemezést</span> az alkalmazásnak kell tartalmaznia!</p><p class="vissza"><a href="#fejezetek">Vissza a tartalom<span class="gyorsb">j</span>egyzékhez</a></p> 
  </div>
</div>
<div class="utmutato_also">
  <div class="utm_hivatkozasok_also"><a class="oldalteteje" accesskey="f" href="#teteje"><span class="gyorsb">F</span>el a lap tetejére</a>
  <a class="elozotanlap" id="navialsoelozo" href="lecke5_lap4.html"><img src="navi/ikon_elozolap.gif" alt="Ugrás a tananyag előző oldalára" title="Ugrás a tananyag előző oldalára" width="36" height="36" /></a>
  <a id='navialsokov' class="kovetktanlap" href="teszt/lecke5/teszt.html"><img src="navi/ikon_kovetklap.gif" alt="Ugrás a tananyag következő oldalára" title="Ugrás a tananyag következő oldalára" width="36" height="36"/></a>
  </div>
</div>
<div class="ki_stilus"></div>
<div class="impresszum">
  <table class="uszt">
    <tr>
      <td><div class="imp_eltetatklogo"><img alt="ELTE és ELTE TáTK logó" src="css/arculat/elte_plus_tatk.png" style="width:100%;height:auto;" /></div>
        <div class="imp_elteiklogo"><img alt="ELTE és ELTE IK logó" src="css/arculat/elte_plus_ik.png" style="width:100%;height:auto;" /></div></td>
      <td><div class="imp_uszt"><img alt="Új Széchenyi terv" src="css/arculat/USZT_logo_cmyk.jpg" style="width:100%;height:auto;" /></div></td>
      <td><div class="imp_eu"><img alt="A projekt az Európai Unió támogatásával, az Európai Szociális Alap társfinanszirozásával valósul meg." title="A projekt az Európai Unió támogatásával, az Európai Szociális Alap társfinanszirozásával valósul meg." src="css/arculat/ESZA.png" style="width:100%;height:auto;"/></div></td>
    </tr>
  </table>
</div>
</body>
</html>
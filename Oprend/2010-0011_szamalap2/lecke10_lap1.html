<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="hu" lang="hu">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="css/scormelte_alap.css" rel="stylesheet" type="text/css" title="" />
<link href="css/style_spec.css" rel="stylesheet" type="text/css" />
<link href="css/scormelte_nagy.css" rel="alternate stylesheet" type="text/css" title="nagy" />
<link href="css/scormelte_inverz.css" rel="alternate stylesheet" type="text/css" title="inverz" />
<!--[if lte IE 6]>
<link href="css/scormelte_ie6.css" rel="stylesheet" type="text/css" title="" />
<![endif]-->
<!-- syntax highlight -->
<link rel="stylesheet" type="text/css" href="css/shCore.css" />
<link rel="stylesheet" type="text/css" href="css/shThemeDefault.css" />
<script type="text/javascript" src="js/shCore.js"></script>
<script type="text/javascript" src="js/shBrushCpp.js"></script>
<script type="text/javascript" src="js/shBrushCSharp.js"></script>
<script type="text/javascript" src="js/shBrushDelphi.js"></script>
<script type="text/javascript" src="js/shBrushXml.js"></script>
<script type="text/javascript" src="js/shBrushCss.js"></script>
<script type="text/javascript" src="js/shBrushJScript.js"></script>
<script type="text/javascript" src="js/shBrushSql.js"></script>
<script type="text/javascript">
SyntaxHighlighter.all()
</script>
<title>
Számítógépes alapismeretek II.</title>
<meta name="description" content="A tananyag  fejlesztése a TÁMOP-4.1.2.A/2-10/1 pályázat keretén belül történt." />
<meta name="keywords" content="Hardver alapismeretek, operációs rendszer, számítógépes alapismeretek, operációs rendszer fogalma, operációs rendszerek története, operációs rendszer feladata, operációs rendszer generációk, operációs rendszer típusok, folyamatok, folyamat táblázat, szál &ndash; folyamatok, rendszerhívások, operációs rendszer struktúrák, kernelmód, kernel, felhasználói mód, B/K művelet, folyamatok modellje, szinkron rendszerhívás, asszinkron rendszerhívás, állapotai, megvalósításuk, folyamatok kommunikációja, IPC (Inter Process Communication), megszakítástábla, IDT, megszakításvezérlő, PIC, megszakítás, interrupt, megszakításkérelem, IRQ, megszakításkezelési folyamat, kivétel, hibakeresés (debuggolás), töréspont, fájlrendszer, MBR, partíciós szektor, Ntldr, klaszter (cluster), szektor, FAT, NTFS, ext, TSS, csapda, ütemezés, szál, szemafor, mutex, monitor, POSIX, szignál, osztott memória, csővezeték, kritikus szakasz, Wybe Dijkstra, CPU, erőforrás, holtpont, kiéheztetés, integrált áramkör, multiprogramozás, beágyazott rendszerek, partíció, MMU, lapcsere, FIFO, socket, lapozás, swap, interaktív rendszer, kötegelt rendszer, kliens, job, jogosultság, metaadat, könyvtár, UNIX, GNU/LINUX, erőforrás-foglalási gráf, fizikai memória, virtuális memória, merevlemez, floppy, fregmentáció, defregmentáló program, MFT, API, i-node, cache memory, SSH, HyperThread, párhuzamosság" />
<script type="text/javascript" src="js/jquery-1.3.2.min.js"></script>
<script type="text/javascript" src="js/kep.js"></script>
<script type="text/javascript" src="js/jquery.media.js"></script>
<script type="text/javascript" src="js/jquery.highlight-3.js"></script>
<script type="text/javascript" src="js/kereses.js"></script>
<script type="text/javascript" src="js/stylesheetToggle.js"></script>
<script type="text/javascript" src="js/cookie.js"></script>
<script type="text/javascript" src="js/stilusvalto.js"></script>
<script type="text/javascript" src="js/fogalmak.js"></script>
<script type="text/javascript" src="js/fogalom.js"></script>
<script type="text/javascript" src="js/jwplayer.js"></script>
<script type="text/javascript">
$(document).ready(function() 
{
$("a.hang").media( {width: 250, height: 50,  autoplay: false} );
});
</script>
<script type="text/javascript" src="js/navigacio.js"></script>
</head>
<body>
<div><a name="teteje"  id="teteje"></a></div>
<div class="jawsfmenu">
  <ul>
    <li><a class="tartalom" href="#tartalom" accesskey="t" tabindex="2">Ugrás a <span class="gyorsb">t</span>artalomra</a></li>
    <li><a class="tartalomj" href="#fejezetek" accesskey="j" tabindex="5">Ugrás a tartalom<span class="gyorsb">j</span>egyzékre</a></li>
    <li><a class="tanutm" href="#tanutm" accesskey="u" tabindex="7">Ugrás a tan<span class="gyorsb">u</span>lási útmutatóra</a></li>
  </ul>
</div>
<div class="ki_kereses"></div>
<div class="oldal">
  <div class="utmutato">
    <div class="utm_hivatkozasok"><span class="elozolap"><img src="navi/ikon_vissza_dis.gif" alt="Vissza az előzőleg látogatott oldalra (nem elérhető funkció)" title="Vissza az előzőleg látogatott oldalra (nem elérhető funkció)" /></span><a class="kezdolap" href="index.html" accesskey="p" tabindex="21"><img src="navi/ikon_kezdolap.gif" alt="Vissza a modul kezdőlapjára" title="Vissza a modul kezdőlapjára" width="36" height="36"/></a><a class="elozotanlap" href="teszt/lecke9/teszt.html" accesskey="e" tabindex="22"><img src="navi/ikon_elozolap.gif" alt="Ugrás a tananyag előző oldalára" title="Ugrás a tananyag előző oldalára" width="36" height="36" /></a><a class="kovetktanlap" href="lecke10_lap2.html" accesskey="v" tabindex="23"><img src="navi/ikon_kovetklap.gif" alt="Ugrás a tananyag következő oldalára" title="Ugrás a tananyag következő oldalára" width="36" height="36"/></a><span class="ki_fogalomkapcs"><img src="navi/ikon_fogalmakbe_dis.gif" alt="Fogalom megjelenítés (nem elérhető funckió)" title="Fogalom megjelenítés (nem elérhető funckió)" /></span><span class="ki_fogalomlista"><img src="navi/ikon_fogalmaklista_dis.gif" alt="Fogalmak listája (nem elérhető funkció)" title="Fogalmak listája (nem elérhető funkció)" /></span><span class="ki_nyomtatas"><img src="navi/ikon_nyomtatas_dis.gif" alt="Oldal nyomtatása (nem elérhető funkció)" title="Oldal nyomtatása (nem elérhető funkció)" /></span><a class="oldalterkep" href="oldalterkep.html" accesskey="d" tabindex="31"><img src="navi/ikon_oldalterkep.gif" alt="Oldaltérkép megtekintése" title="Oldaltérkép megtekintése"  width="36" height="36" /></a><a class="sugo" href="sugo.html" accesskey="s" tabindex="33"><img src="navi/ikon_sugo.gif" alt="Súgó megtekintése" title="Súgó megtekintése"  width="36" height="36" /></a></div>
    <h1 class="utmutato"><a name="tanutm"  id="tanutm"></a>Tanulási útmutató</h1>
    <div class="osszefoglalas">
      <h2>Összefoglalás </h2>
      <!--{fej10_hang_1}--><div class="hang"><ul><li><strong>Cím:</strong> <a href="hangok/10.ogg">A memóriakezelés</a></li><li><strong>Hossz:</strong>0 perc 47 <abbr title="másodperc">mp.</abbr></li><li><strong>Fájlméret:</strong> 0.8 <abbr title="megabájt">MB</abbr></li><li><a class="media hang" name="playerf25" id="playerf25" href="hangok/10.ogg">A memóriakezelés című hanganyag letöltése</a></li><li><a href="hangok/10.html"><span class="jaws">A memóriakezelés című hanganyag</span>Szöveges változat megtekintése</a></li></ul></div><!--END{fej10_hang_1}--><p>A memóriakezelés alapvetően két szinten történhet: </p><ul><li>Az <span class="fogalom" title="operációs rendszer">operációs rendszer</span> szintjén. Az <span class="fogalom" title="operációs rendszer">operációs rendszerek</span> olyan fejlettségi szintjén, ahol a fő jellemzőik a multitasking, valamint az időosztás. Felügyelni és vezérelni kell a &#132;futó&#148; programoknak az aktiválását, illetve passzívvá tételét. Adminisztrálni és védeni kell az egyes programok eszközigényeit. </li><li>A felhasználó által programnyelvi környezetben való memóriakezelés. Itt két dolgot vizsgálunk: a memóriához való direkt hozzáférést a memória címzési módszerein keresztül, valamint különböző <span class="fogalom" title="szál">szálon</span> futó programok azonos memóriaterület-használatát (osztott memóriakezelés).</li></ul> 
    </div>
    <div class="kovetelmeny">
      <h2>Követelmény </h2>
      <p>A tanuló legyen tisztában a memóriahasználattal monoprogramozás, illetve multiprogramozás esetében. Ismerje a lapcserélés alapvető lehetőségeit. Ismerje a <span class="fogalom" title="virtuális memória">virtuális memória</span> használatának mibenlétét. Ismerje az alapvető lapcserélési algoritmusokat, valamint a szegmentálás fogalmát, jelentőségét. Ismerje a felhasználói szintű memóriakezelés címzési módszereit. Legyen tisztában az <span class="fogalom" title="osztott memória">osztott memória</span> használatához szükséges alapvető műveletekkel.</p> 
    </div>
    <div class="feladatok">
      <h2>Önállóan megoldható feladatok</h2>
      <ul><li> Gyűjtsd ki egy táblázatba, hogy változtak a processzorok regiszterei!(x86, x286,x386,x486) Használd az internetes adatgyűjtés lehetőségét!</li><li> Csoportosítsd a mov adatmozgató utasításokat a címzési módok szerint!</li></ul> 
    </div>
  </div>
  <div class="tartalommenu">
    <div class="tartalommenu_fejlec"><span id="lapteteje"><a  href="#teteje"><span class="gyorsb">F</span>el a lap tetejére</a></span><a name="fejezetek"   id="fejezetek">Tartalomjegyzék</a></div>
    <ul><li><a href="#hiv1">Memóriakezelés, alapvető módszerek, virtuális memória, szegmentálás és megvalósításuk a mai processzorokban</a><ul><li><a href="#hiv2">Az operációs rendszer szintű memóriakezelés </a></li><li><a href="#hiv3">A lapozási technika </a></li></ul></li></ul> 
  </div>
  <div class="tartalom"> <a name="tartalom" id="tartalom"></a> 
    <h1><a name="hiv1" id="hiv1" ></a>Memóriakezelés, alapvető módszerek, virtuális memória, szegmentálás és megvalósításuk a mai processzorokban</h1><h2><a name="hiv2" id="hiv2" ></a>Az operációs rendszer szintű memóriakezelés </h2><p>Az alapvető memóriakezelési módszerek két csoportba sorolhatók:</p><ul><li>végrehajtás közben mozgatják az egyes processzusokat a központi tár és a lemezterületek között (ennek módszerei a <span class="fogalom" title="lapozás">lapozás</span>, illetve a csere);</li><li>már a betöltéskor eldől, hogy mi hova kerül, és a futás végéig állandósul a memória, azaz a programon belüli esetleges dinamikus definíciókon kívül a memóriának a &#132;programot&#148; tartalmazó része állandó. </li></ul><p>A második módszer egyszerűsége és lényegében már alig használt módja miatt kezdjük ezzel! Itt három dolgot érdemes megemlíteni: </p><ul><li>A legegyszerűbb memóriakezelési módszer az, hogy időben csak egyetlen programot futtatunk <strong>(monoprogramozás)</strong>, ami annyit jelent, hogy a memóriát csak saját programunk, illetve az <span class="fogalom" title="operációs rendszer">operációs rendszer</span> között kell &#132;felosztani&#148;. Ezt a felosztást háromféleképpen végezhetjük &ndash; a sorrend a kisebb címtől a nagyobb cím felé haladást jelenti: <ul><li>felhasználói program, <span class="fogalom" title="operációs rendszer">operációs rendszer</span> a RAM-ban &ndash; ezt a felosztást régi nagyszámítógépes rendszerekre, illetve miniszámítógépeken (Commodore, HT-1080Z) használták;</li><li><span class="fogalom" title="operációs rendszer">operációs rendszer</span> a RAM-ban, felhasználói program &ndash; főleg <span class="fogalom" title="beágyazott rendszerek">beágyazott rendszerek</span> használják ezt a felosztást; </li><li>eszközmeghajtók a ROM-ban, felhasználói program, <span class="fogalom" title="operációs rendszer">operációs rendszer</span> a RAM-ban &ndash; korai személyi számítógépekre jellemző. Lényegében a ROM-ba égetett rész nem más BIOS (Basic Input-Output System). </li></ul></li></ul><p>Monoprogramozás <span class="fogalom" title="swap">swapping</span> vagy <span class="fogalom" title="lapozás">lapozás</span> nélkül. Az alábbi ábra mutatja, hogy ebben a környezetben a programunk, mint egyetlen végrehajtandó feladat (ezért monoprogramozás az elnevezés) hol helyezkedik el a memóriában az operációs rendszerhez képest.</p><!--fej10_kep_1--><div class="kep kozep sz400"><img src="kepek/fej10_kep1_w400.jpg" alt="A képen a monoprogramozás esetén a felhasználói program elhelyezkedése látható" style="width:100%; height:auto;" title="A képen a monoprogramozás esetén a felhasználói program elhelyezkedése látható" /><span class="kepalairas">Monoprogramozás esetén a felhasználói program elhelyezkedése</span><div class="kep_ikonok jobbra"><span class="kep_nagymeret"><a href="kepek/fej10_kep1_w400_full.html" title="Kép megtekintése külön ablakban" >A fenti kép <span class="kepnev">(fej10_kep1_full.jpg)</span> megtekintése külön ablakban</a></span></div></div><div class="uresmargo"></div><!--ENDfej10_kep_1--><ul><li>Fejlettebb szint a <strong>multiprogramozás</strong> rögzített <span class="fogalom" title="partíció">partíciókkal</span>. Ekkor a rendelkezésre álló memóriát felosztják több, általában nem egyforma hosszúságú részre. Működéséhez minden <span class="fogalom" title="partíció">partíciónak</span> szüksége van egy úgynevezett várakozási sorra. Ha beérkezik egy igény, az <span class="fogalom" title="operációs rendszer">operációs rendszer</span> berakja annak a legkisebb méretű, <span class="fogalom" title="partíció"><strong><em>partíciónak</em></strong></span><strong><em> </em></strong>nevezett rész várakozási sorába, ahová még befér. Ilyenkor elvész a <span class="fogalom" title="partíció">partíciónak</span> az a része &ndash; nem használható &ndash;, amit az éppen futó processz nem használ. Ha az adott szeletben befejeződik a munka, a legrégebben várakozó megkapja a területet, és elkezd működni. Kicsit jobb változat, ha egyetlen várakozási sorba érkeznek az igények, és a felszabadult <span class="fogalom" title="partíció">partícióba</span> az a legrégebben várakozó kerül, amelyik &#132;befér&#148; erre a helyre. Ez a technika két probléma megoldását igényli: egyrészt tudni kell a szerkesztőprogramnak, hogy a betöltéskor hogyan módosuljanak az utasítások végrehajtási címei (relokáció), valamit mi módon védhetők a keveredéstől az egyes processzek utasításai. Ezt általában úgy oldják meg, hogy két kitüntetett jellemzőt megjegyeznek minden egyes <span class="fogalom" title="partíció">partícióhoz</span>: az úgynevezett bázist és a határt; ezek egy-egy kitüntetett memóriarészben, <strong><em>regiszterekben</em></strong> tárolódnak. Az esetleges téves hivatkozások a segítségükkel kiszűrhetők, és megfelelő hibakezeléssel nem történik nagyobb baj.</li></ul><p>A multiprogramozás megjelenése fix <span class="fogalom" title="partíció">partíciók</span> esetén, jellemzően kétféle módon valósult meg. Egyik esetben (bal oldali rajz) különböző méretű <span class="fogalom" title="partíció">partíciókat</span> definiálunk és a megfelelő programot a hozzá méretben illeszkedő várakozási sorba rakjuk. Hátránya a megvalósításnak, hogy több várakozási sort (queue) kell nyilvántartani és menedzselni.</p><p>Másik esetben csak egy várakozási sort használunk (jobb oldali rajz), ekkor a megüresedett <span class="fogalom" title="partíció">partíció</span> helyére az a program kerül, amelyik a sorban előrébb van és bele is fér a <span class="fogalom" title="partíció">partícióba</span>! Ebben az esetben kis módosítása lehet a kiválasztásnak, hogy nem az első beleférő programot helyezzük bele a <span class="fogalom" title="partíció">partícióba</span>, hanem a beleférők közül a legnagyobbat. Ezzel a módszerrel a <span class="fogalom" title="partíció">partíció</span> veszteséget lehet minimalizálni. Ekkor még egy javítást lehet meggondolni. Egy-egy programválasztás során a <span class="fogalom" title="partíció">partícióba</span> több program fér be, a nem kiválasztottakhoz jegyezzük fel, hogy most éppen nem volt szerencséjük. Ezt a szerencsétlenség számlálót növeljük egyel. Megadhatunk egy korlátot (k), amit ha elér egy vagy több program, akkor a sorban első k-t elérő programot választjuk ki. Ezzel azt érjük el, hogy nem várakozik végtelen ideig egyik program se a memóriába kerüléshez.</p><p>Multiprogramozás fix <span class="fogalom" title="partíció">partíciókkal</span></p><p> <!--fej10_kep_2--><div class="kep kozep sz650"><img src="kepek/fej10_kep2_w650.jpg" alt="A képen a következő látható: egyszeres-többszörös sorok használata a partíciók elosztásához" style="width:100%; height:auto;" title="A képen a következő látható: egyszeres-többszörös sorok használata a partíciók elosztásához" /><span class="kepalairas">Egyszeres-többszörös sorok használata a partíciók elosztásához</span><div class="kep_ikonok jobbra"><span class="kep_nagymeret"><a href="kepek/fej10_kep2_w650_full.html" title="Kép megtekintése külön ablakban" >A fenti kép <span class="kepnev">(fej10_kep2_full.jpg)</span> megtekintése külön ablakban</a></span></div></div><div class="uresmargo"></div><!--ENDfej10_kep_2--></p><p>Az időosztásos rendszereknél az előbbinél fejlettebb technikát használnak. Ennek lényege, hogy milyen módon történik az igények kielégítése. Itt már nincsenek rögzített <span class="fogalom" title="partíció">partíciók</span>, amíg van hely, addig folyamatosan töltődnek a processzusok, majd egy jól meghatározott elv alapján, az idő előrehaladásával, változik a memória tartalma. Alapvetően két módszer létezik: </p><ul><li><strong><em>Csere vagy <span class="fogalom" title="swap">swapping</span></em></strong>. Ez a technika az &#132;azonos&#148; időben futó programokat teljes egészében &ndash;a méretüknek megfelelően &ndash; mozgatja a lemezterület és a memória között. Mivel egy-egy processz működésének végeztével felszabadul a memória általa használt része, de nincs mit betölteni, a memóriában lyukak keletkeznek. Emiatt jelentősen csökkenhet a memória kihasználtsága, így szükség van a lyukak &#132;egyesítésére&#148;, amit <strong><em>memóriatömörítésnek </em></strong>nevezünk. Ilyenkor a rendszernek arra kell ügyelnie, hogy bent lévő processzek ne sérüljenek (az esetleges áthelyezések miatt újra kell számolni az utasítások címeit).  A következő ábra ezt a csere folyamatot szemlélteti. Az A folyamat kikerül a memóriából, a háttértáron kerül elhelyezésre, míg a B folyamat a háttértárból a fizikai memóriába kerül. </li></ul><p><strong><em><!--fej10_kep_3--><div class="kep kozep sz500"><img src="kepek/fej10_kep3_w500.jpg" alt="A képen az A-B folyamatok memória cseréje látható" style="width:100%; height:auto;" title="A képen az A-B folyamatok memória cseréje látható" /><span class="kepalairas">A-B folyamatok memória cseréje</span><div class="kep_ikonok jobbra"><span class="kep_nagymeret"><a href="kepek/fej10_kep3_w500_full.html" title="Kép megtekintése külön ablakban" >A fenti kép <span class="kepnev">(fej10_kep3_full.jpg)</span> megtekintése külön ablakban</a></span></div></div><div class="uresmargo"></div><!--ENDfej10_kep_3--></em></strong></p><ul><li>A cserék adminisztrálására kétféle módszert dolgoztak ki: <ul><li><strong><em>Bittérképes cserekezelés</em></strong>. A memóriát, szónyi vagy kilobájtnyi egységekre osztjuk.(Talán leggyakrabban ma 4KB egységről beszélhetünk, de előfordulhat 2/4 MB is.) Minden egységhez hozzárendelünk egy-egy foglaltsági bitet. Ennek értéke egy, ha foglalt és nulla, ha szabad. Új processz érkezésekor olyan összefüggő szabad területet kell keresni, melyek együttes hossza elegendő az új tevékenység betöltéséhez. Az allokációs területek hosszának tervezésekor figyelembe kell venni, hogy a csere lehetőleg gyors legyen (a keresési algoritmusok is időt igényelnek), valamint ne foglaljon aránytalanul sok memóriát, hiszen akkor megint sehol sem vagyunk. </li><li><strong><em>Láncolt listás cserekezelés.</em></strong> Ennél a technikánál egy kétirányú listába fűzzük a memóriában szereplő allokációs elemeket, a szabad helyeket, valamint a valamilyen processz által foglalt területeket. A lista ezek után egy négy elemet tartalmazó rekord: a terület jellege (szabad, foglalt), a terület kezdőcíme, a terület hossza, illetve a következő elem címe (mutató). Célszerű a listát kezdőcím szerint rendezetten kezelni, így egyszerűbb helyet keresni egy új feladatnak, valamint egyszerűbb a lyukakat összevonni. Nézzük meg, hogy milyen módon kereshetünk helyet egy új processznek. Feltesszük, hogy a memóriakezelő tudja az igényelt hely nagyságát: <ul><li><strong><em>firstfit:</em></strong> megkeresi az első olyan üres helyet, amiben elférünk, majd két részre osztja a területet: az egyik tartalmazza magát a processzt, a maradék rész pedig szabad listaelem lesz; </li><li><strong><em>nextfit:</em></strong> az utolsó szabad helytől keres üres területet; </li><li><strong><em>bestfit: </em></strong>az egész listában keresi azt a legkisebb szabad területet, ahol elfér a processz. Természetesen az eljárás általában lassabb, mint az előbbiek, viszont helyet talál olyan processzeknek is, amelyeknek az előző két módszer nem talál a nagy helyigény miatt. Azok ugyanis kis igényhez is az első szabad helyet rendelik, ami lehet, hogy nagyobb igénynek is megfelelne; </li><li><strong><em>worstfit:</em></strong> a legnagyobb szabad lyukat választja; </li><li>a módszerek javíthatóak azáltal, hogy külön listában kezeljük a foglalt, illetve a szabad területeket. Tovább javítható bizonyos előfeltételek teljesülése esetén: például ha elég egyformák a processzek méretei, akkor a leggyakoribb mérethez külön szabadlistát készítünk, és ebben keresünk. Ezt a módszert <strong><em>quickfit </em></strong>technikának nevezik. </li></ul></li></ul></li></ul><p>A bittérképes, láncolt listás memória nyilvántartást szemlélteti a következő sematikus ábra. Az A,B,C, stb karakterek az egyes folyamatokat rövidítik, ezek elhelyezkedését, foglaltsági térképét a memóriában a kép bal oldali táblázata illusztrálja. A láncolt listás megvalósításnál, a P (program) jelzés után az első szám a memória kezdőcímét mutatja, a második szám a lefoglalt memória egységek számát. Üres memóriablokk (Ü) esetén hasonló értelmezést használhatunk.</p><ul><li><span class="fogalom" title="virtuális memória"><strong><em>virtuális memória</em></strong></span><strong><em>. </em></strong>A fejlődés következő foka az volt, amikor lehetőség nyílt arra, hogy ne csak teljes &#132;programok&#148; legyenek a memóriában, hanem csak az éppen működő futó részek. Ehhez a programokat úgynevezett rétegekre kell darabolni az <strong><em>overlay </em></strong>technika révén. Mivel a mozgatást eleve az <span class="fogalom" title="operációs rendszer">operációs rendszer</span> végzi, azzal nincsen gond. A technika kezdeti használatakor azonban a darabolást még a programok készítői végezték. Az <span class="fogalom" title="operációs rendszer">operációs rendszer</span>rel való megoldás a <span class="fogalom" title="virtuális memória"><strong><em>virtuális memória</em></strong></span><strong><em> </em></strong>(1961, Fotheringham)<strong><em>. </em></strong>A modern <span class="fogalom" title="operációs rendszer">operációs rendszerek</span> képesek arra, hogy látszólag több memóriát biztosítsanak a programoknak, mint amennyi fizikailag a rendelkezésükre áll. A módszert <strong><em>virtuális memóriakezelésnek</em></strong> hívják. </li></ul><p class="vissza"><a href="#fejezetek">Vissza a tartalom<span class="gyorsb">j</span>egyzékhez</a></p><h2><a name="hiv3" id="hiv3" ></a>A lapozási technika </h2><p>Minden program előállít valamilyen memóriacím-halmazt; ezeket <strong><em>virtuális címekne</em></strong>k nevezik. Ha nincs meg ez az eszközünk, akkor a memóriacímek közvetlenek. Ha használjuk a virtuális technikát &ndash; a programunk nem fér be egyszerre még az egyre nagyobb és nagyobb memóriába se &ndash;, akkor a címek nem közvetlen memóriacímek, hanem egy <span class="fogalom" title="MMU">MMU</span> (Memory Management Unit) nevű egységbe kerülnek, ami leképezi azt egy fizikai címmé. Ezt a címteret <strong>lapokba</strong> szervezik, amelynek fizikai megfelelője a <strong>lapkeret</strong>. Egy-egy lap mérete általában fél kilobájt és egy megabájt közé esik. A lapokat laptáblák adminisztrálják, amelyek a minél gyorsabb működés érdekében mindig a memóriában vannak. Általánosan elmondható még, hogy jellemzően az operációs rendszer által nyilvántartott virtuális címtér nagyobb, mint a rendelkezésre álló <span class="fogalom" title="fizikai memória">fizikai memória</span>, így a <span class="fogalom" title="virtuális memória">virtuális memória</span> nyilvántartás alapvető feladata az, hogy tudjuk melyik virtuális lapkeret van jelen a fizikai memóriába és hol. Ezt a hozzárendelést szemlélteti a következő ábra.</p><p>Ahogy látható, a rajzon egy lap 4KB méretű, ez ma is egy átlagos, jellemző érték, a virtuális címtérben egy lapkeretnél X betű jelzi, hogy nincs benn a fizikai memóriában.</p><!--fej10_kep_5--><div class="kep kozep sz500"><img src="kepek/fej10_kep5_w500.jpg" alt="A képen a virtuális memória címtér-fizikai memória címzés megfeleltetés látható." style="width:100%; height:auto;" title="A képen a virtuális memória címtér-fizikai memória címzés megfeleltetés látható." /><span class="kepalairas">Virtuális memória címtér-fizikai memória címzés megfeleltetés</span><div class="kep_ikonok jobbra"><span class="kep_nagymeret"><a href="kepek/fej10_kep5_w500_full.html" title="Kép megtekintése külön ablakban" >A fenti kép <span class="kepnev">(fej10_kep5_full.jpg)</span> megtekintése külön ablakban</a></span></div></div><div class="uresmargo"></div><!--ENDfej10_kep_5--><p>A program végrehajtás során a processzor virtuális címet küld az MMU-nak, az ha szükséges betölti a megfelelő lapot a háttértárból a fizikai memóriába, és átfordítja a virtuális címet az keletkező fizikai címmé.</p><!--fej10_kep_6--><div class="kep kozep sz400"><img src="kepek/fej10_kep6_w400.jpg" alt="A képen az látható, hogy a processzor hogyan küld virtuális címeket az MMU-nak" style="width:100%; height:auto;" title="A képen az látható, hogy a processzor hogyan küld virtuális címeket az MMU-nak" /><span class="kepalairas">Virtuális-fizikai cím változás</span><div class="kep_ikonok jobbra"><span class="kep_nagymeret"><a href="kepek/fej10_kep6_w400_full.html" title="Kép megtekintése külön ablakban" >A fenti kép <span class="kepnev">(fej10_kep6_full.jpg)</span> megtekintése külön ablakban</a></span></div></div><div class="uresmargo"></div><!--ENDfej10_kep_6--><p>Ez a fizikai-virtuális cím megfeleltetés nem feltétlenül jelent bonyolult számításokat. Ezt illusztrálja a következő 16 bites virtuális címtér konvertálást mutató ábra. Ehhez hasonló ábra sok forrásban megtalálható, például A.Tanenbaum, A.Woodhull Operációs rendszerek könyvében is, azt illusztrálja, hogy ez a konvertálás gyors művelet tud lenni, bár a 16 bites virtuális címtér csak illusztrációs méretű!</p><p>A lenti ábra tetején megjelenő 16 bites virtuális címből (64 KB a virtuális címterünk, 4KB (12 bites) egy lap mérete és 32KB (15 bit) a <span class="fogalom" title="fizikai memória">fizikai memória</span> nagysága), hogyan állítunk elő egy 15 bites fizikai címet. A 16 bites cím felső 4 bitjét használjuk a laptábla indexeként(0010=2), ezen indexű laptábla elem szintén 4 bites, mondjuk ennek felső 3 bitje a 12 bit kiegészítő bitjeit adja a 15 bites fizikai cím meghatározásához. A 4.bit a jelenlét bit. Ha nincs a fizikai memóriában a kért virtuális lapnak megfelelő memória, akkor jön a <span class="fogalom" title="lapcsere">lapcsere</span>, kitöltésre kerül a laptábla megfelelő bejegyzése, és folytatódik a program végrehajtás. </p><p>Természetesen ha ez a lapcserés címmeghatározás él, még ezen ügyes módszer mellett is jelentős program futás lassulás tapasztalható. Ma még gyakran használnak például Windows XP operációs rendszert. Ebben a rendszerben a maximálisan használt <span class="fogalom" title="fizikai memória">fizikai memória</span> 2GB. Ha elérjük azt, hogy a futó alkalmazások teljes memória felhasználása közelíti a fizikai határt, azt tapasztalhatjuk, hogy szinte folyamatosan ég a <span class="fogalom" title="merevlemez">merevlemez</span> használatot jelző kis led, mutatva azt, hogy nagyon gyakran  azt találja a memória kezelő egység, hogy a kért cím éppen lemezen van és <span class="fogalom" title="lapcsere">lapcsere</span> kell! Ezen aktivitást mutató fényen kívül azt is tapasztaljuk, hogy sok esetben jelentősen romlik a programunk futási teljesítménye!</p><!--fej10_kep_7--><div class="kep kozep sz500"><img src="kepek/fej10_kep7_w500.jpg" alt="A képen a virtuális-fizikai lap konverzió látható" style="width:100%; height:auto;" title="A képen a virtuális-fizikai lap konverzió látható" /><span class="kepalairas">Virtuális-fizikai lap konverzió</span><div class="kep_ikonok jobbra"><span class="kep_nagymeret"><a href="kepek/fej10_kep7_w500_full.html" title="Kép megtekintése külön ablakban" >A fenti kép <span class="kepnev">(fej10_kep7_full.jpg)</span> megtekintése külön ablakban</a></span></div></div><div class="uresmargo"></div><!--ENDfej10_kep_7--><p>Egy bejegyzés a következő információkat tartalmazza: </p><ul><li>a lapkeret száma talán a legfontosabb információ, a <span class="fogalom" title="lapozás">lapozási</span> algoritmus célja ennek előállítása, hiszen itt helyezkedik el az a cím, melyet egy adott hivatkozás használ; </li><li>a következő bit írja le, hogy a cím a memóriában van-e, vagy sem. Hiányjel (&rsquo;) esetén a memóriában van, és az előző adat tartalmazza, hogy hol. Ha ez a bit nulla, akkor az előző adatnak nincs értéke, hiszen nincs a memóriában; </li><li>azt jelzi, hogy mit tehetünk a lappal: írhatunk és olvashatunk, vagy csak írhatunk, esetleg végrehajtás is engedélyezett; </li><li>a módosítás és hivatkozás bitnek lap eltávolításkor van jelentősége, ha módosult, akkor a lemezen is felül kell írni az adott lap tartalmát; </li><li>a gyorsító tár használatának letiltása főleg akkor fontos, ha a rendszer valamilyen I/O eszközre vár. Ilyenkor célszerű, ha magától a rendszertől kap választ. </li></ul><p>Fontos elemei a virtuális memóriakezelésnek a <strong><em>lapcserélési algoritmusok</em></strong>. Ezek többfélesége egyrészt a fejlődésüket, hatékonyabbá válásukat mutatja, másrészt esetleg ismerve a feladat milyenségét, egyikük valamilyen szempontból jobb lehet egy másiknál. Akkor válik szükségessé <span class="fogalom" title="lapcsere">lapcsere</span>, ha a használni kívánt programrész nincs a memóriában. Ezt az eseményt <strong><em>laphibának </em></strong>nevezik, ami kiváltja a lapcserélési eljárás megindítását. </p><ul><li><strong><em>Optimális</em></strong> &ndash; egyben megvalósíthatatlan &ndash; <strong>lapcserélési algoritmus.</strong> Ennek lényege, hogy a memóriában levő minden lapot megcímkézünk azzal a számmal, amelyik azt jelzi, hogy hány utasítás végrehajtása után kerül erre a lapra &#132;sor&#148;. Nyilván a legnagyobb számú lapot kellene kidobni, de az <span class="fogalom" title="operációs rendszer">operációs rendszerek</span> nem tudják megmondani a számot. Ehhez ugyanis először &#132;virtuálisan&#148; le kellene futtatni a programot, ami nyilvánvalóan abszurditás.</li><li><strong>NRU </strong>(Not Recently Used, nem mostanában használt) <strong>lapcserélési algoritmus.</strong> Minden laphoz, ami a memóriába kerül, hozzárendelünk még két bitet: egy R bitet, amely minden hivatkozáskor (akár olvasás, akár írás) egyesre állítódik, és egy M bitet, ami módosításkor kap 1-es értéket. Ennek alapján a memóriába lévő lapok négy osztályba sorolhatóak: <ul><li>0. osztály: 00 (nem hivatkozott, nem módosított); </li><li>1. osztály: 01 (nem hivatkozott, módosított),</li><li>2. osztály: 10 (hivatkozott, nem módosított); </li><li>3. osztály: 11 (hivatkozott, módosított). </li></ul></li><li>A módszer az, hogy véletlenszerűen kiválaszt a legalacsonyabb sorszámú osztályból egyet, és azt kidobja. Egyszerű módszer, könnyen megvalósítható. </li><li><strong><span class="fogalom" title="FIFO">FIFO</span> lapcserélési algoritmus.<em> </em></strong>A sor-adatszerkezet műveleteinek megfelelően <span class="fogalom" title="lapcsere">lapcsere</span> esetén a legrégebben bent lévő lapot eldobja, és a sor végére teszi az újonnan érkezőt. </li><li><strong>Second chance </strong>(második lehetőség)<strong> lapcserélési algoritmus.<em> </em></strong>A <span class="fogalom" title="FIFO">FIFO</span> olyan módosítása, amelyben a legrégebbi egyes hivatkozású lapot nullás bittel a sor végére teszi, és keresi tovább a megfelelőt. </li><li><strong>Az óra lapcserélési algoritmus.<em> </em></strong>A bent lévő lapokat egy láncnak képzeljük, azaz nincs első és utolsó, eleje meg vége elem, hanem egy aktuális elem, amellyel utoljára volt dolgunk laphiba esetén. Innen indulva szintén az R bitet vizsgáljuk: amennyiben ez egyes, akkor nullára állítjuk, és megyünk tovább. Lényegében az előző algoritmus, csak a kitüntetett elem &ndash; ahonnan a keresés indul &ndash; az utolsónak hivatkozott változásra mutat. </li><li><strong>LRU </strong>(Least Recently Used) <strong>lapcserélési algoritmus.</strong> Talán ez közelíti legjobban az optimális lapcserélést. Statisztikai megfontolásokra támaszkodik: az utoljára használt néhány utasítás által gyakran használt lap valószínűleg továbbra is szükséges lehet; viszont amit régen nem használtunk, valószínűleg még egy darabig nem is kell. Így azt dobjuk el, amelyiket a legrégebben nem használtunk. Az okozhat implementációs nehézséget, hogy minden hivatkozáskor aktualizálni kell a laphivatkozásokat. Ehhez minden lapbejegyzéshez felveszünk egy újabb bejegyzést, amely a lapra hivatkozáskor annak a számlálónak az értékét tartalmazza, amely minden memóriahivatkozás esetén eggyel nő. </li></ul><p>A korábban látott virtuális címtér- fizikai címtér illusztráció(16 bit- 15 bit) nem tükrözi a mai memória méreteket. (Nem is volt ez a cél.) Egy mai átlagos processzor 64 bites, az ebből adódó címzési lehetőségeket messze nem használjuk ki valójában, ezért nézzük meg egy 32 bites processzor esetében mit is jelent a <span class="fogalom" title="virtuális memória">virtuális memória</span> táblázat kezelése! Egy lapkeret mérete jellemzően 12 bites, mint a korábbi illusztrációban volt. Ez azt jelenti, hogy a virtuális laptábla elemszáma 220. Ez kicsivel több mint egymillió! (1024x1024) Azaz a virtuális laptábla táblázatunk elemszáma nem 16, mint a korábbi példában, hanem több mint egymillió. Ennek a táblának a memóriában van a helye. Ez akkora helyet igényel, hogy ennek gyakorlati megvalósítása lehetetlen. Ezért ennek megoldására úgynevezett kétszeres (többszörös) virtuális laptáblákat alkalmaznak. Ebben az esetben például az elsődleges laptábla is 1024 elemű, majd az ehhez tartozó al-laptábla is 1024 elemű. Ennek megfelelően csak a fő 1024 elemű laptábla van állandóan a memóriában, illetve még a szükséges néhány másodlagos laptábla. Ebből a rövid leírásból is érzékelhető, hogy egyrészt a módszer továbbfejleszthető, és akár a 64 bites esetre alkalmazva 5 szintű laptábla rendszert hozzunk létre. Viszont az is könnyen belátható, hogy ennek bonyolultsága már nem ad hatékony megoldást! </p><p>Ebből a helyzetből a megoldást az invertált laptáblák használata adja. Ez azt mondja, hogy nem kell nekünk az egész virtuális címteret laptábla táblázatban tárolni, hanem elég akkora táblázat, amekkora a <span class="fogalom" title="fizikai memória">fizikai memória</span>. Ekkor nem tudjuk a korábbi ábrán mutatott módszert használni, egyszerű asszociatív táblát kapunk, de jóval kisebb méretűt. Ez egyszerűsíti a helyzetet, de kicsit lassítja is, ebben a táblában lassabb a keresés. A gyakorlat viszont azt mutatja, hogy egy futási helyzetben nem gyakran kerül sor lapcserére, illetve csak néhány virtuális lap van használatban. Ez azt jelenti, hogy ha készítenénk egy kisméretű asszociatív táblázatot (nem a <span class="fogalom" title="fizikai memória">fizikai memória</span> méretnek megfelelőt), 32 vagy 64 eleműt, akkor ezt mint gyorsító tárat használva hatékony címfordítást tudnánk végezni. Ezt a táblázatot TLB-nek (Translation Lookaside Buffer- címfordítási gyorsítótár) nevezzük. Voltak olyan környezetek, ahol ezt szoftveresen kezelték, a mai processzorok esetén ez egy hardveres gyorsító tár, ezzel is növelve a hatékonyságot. Az Intel Nehalem architektúrában kétszintű hardveres TLB-t használ (64 elemű DTLB-t vagy 128 elemű ITLB-t az első szintű, L1 gyorsítótárhoz, míg 512 eleműt a másodszintű, L2 gyorsító tárhoz), ezzel segítve a gyors címfordítást. Ezek az elemszámok azt jelentik, hogy csak abban az esetben fordul a memória kezelő az invertált laptáblához ha se az L1, se az L2 TLB-ben nincs a kért cím. Ez meglehetősen ritka eset, azaz ritkán érünk el ahhoz a helyzethez, hogy egy lassú módszerrel kelljen meghatároznunk a virtuális címhez tartozó fizikai lapot. Nyilvánvaló, hogy a processzorok fejlődésének egyik jellemzője, hogy egyre nagyobb méretű TLB-t használ, ezzel is gyorsítva a memória kezelését!</p><p>Az eddig elemzett esetekben a memóriát egy indexes tömbként kezeltük, ami azt jelenti, hogy egyazon helyen voltak az adatok és a programutasítások. Ilyenkor az MMU-nak ennek tudatában kellett kiadni a megfelelő memóriacímet. Kézenfekvő lenne, ha több virtuális memóriát használnánk (természetesen nem sokat). Ezeknek a címei mindig nullával kezdődnek, és a bennük lévő bejegyzések az ehhez képesti eltolási címen vannak. Ezt a címet hívják <strong><em>offszetnek</em></strong>. Hivatkozáskor azt kell eldönteni, hogy melyik virtuális memóriához tartozik a cím, és ennek megfelelően kell az abszolút címet meghatározni. A különálló virtuális memóriákat <strong><em>szegmenseknek</em></strong> nevezik. A mai processzorok mindegyike ezt a címmeghatározást használja. Minden egyes szegmenshez tartozik egy kitüntetett adat, ami betöltéskor aktivizálódik, és a szegmens kezdetének abszolút címét tartalmazza; a neve általában <strong><em>szegmensregiszter</em></strong>. Az adott szegmensbe tartozó hivatkozások abszolút címeit ebből a szegmensregiszter-értékből és a szegmensen belüli eltolásból, az offszetből számolják ki. A következő részben ennek kiszámítási módjára adunk példákat az INTEL8080 processzorcsalád által használt gépi utasításokkal.</p><p class="vissza"><a href="#fejezetek">Vissza a tartalom<span class="gyorsb">j</span>egyzékhez</a></p> 
  </div>
</div>
<div class="utmutato_also">
  <div class="utm_hivatkozasok_also"><a class="oldalteteje" accesskey="f" href="#teteje"><span class="gyorsb">F</span>el a lap tetejére</a>
  <a class="elozotanlap" id="navialsoelozo" href="teszt/lecke9/teszt.html"><img src="navi/ikon_elozolap.gif" alt="Ugrás a tananyag előző oldalára" title="Ugrás a tananyag előző oldalára" width="36" height="36" /></a>
  <a id='navialsokov' class="kovetktanlap" href="lecke10_lap2.html"><img src="navi/ikon_kovetklap.gif" alt="Ugrás a tananyag következő oldalára" title="Ugrás a tananyag következő oldalára" width="36" height="36"/></a>
  </div>
</div>
<div class="ki_stilus"></div>
<div class="impresszum">
  <table class="uszt">
    <tr>
      <td><div class="imp_eltetatklogo"><img alt="ELTE és ELTE TáTK logó" src="css/arculat/elte_plus_tatk.png" style="width:100%;height:auto;" /></div>
        <div class="imp_elteiklogo"><img alt="ELTE és ELTE IK logó" src="css/arculat/elte_plus_ik.png" style="width:100%;height:auto;" /></div></td>
      <td><div class="imp_uszt"><img alt="Új Széchenyi terv" src="css/arculat/USZT_logo_cmyk.jpg" style="width:100%;height:auto;" /></div></td>
      <td><div class="imp_eu"><img alt="A projekt az Európai Unió támogatásával, az Európai Szociális Alap társfinanszirozásával valósul meg." title="A projekt az Európai Unió támogatásával, az Európai Szociális Alap társfinanszirozásával valósul meg." src="css/arculat/ESZA.png" style="width:100%;height:auto;"/></div></td>
    </tr>
  </table>
</div>
</body>
</html>
